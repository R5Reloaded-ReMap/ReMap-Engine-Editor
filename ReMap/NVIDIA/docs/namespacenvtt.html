<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nvtt: nvtt Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">nvtt
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">nvtt Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Namespace for all public non-macro NVTT fields.  
<a href="namespacenvtt.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_compression_options.html">CompressionOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compression options. This class describes the desired compression format and other compression settings.  <a href="structnvtt_1_1_compression_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_output_handler.html">OutputHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inheritable interface for outputting data.  <a href="structnvtt_1_1_output_handler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_error_handler.html">ErrorHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inheritable interface for handling errors.  <a href="structnvtt_1_1_error_handler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_output_options.html">OutputOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output Options.  <a href="structnvtt_1_1_output_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_context.html">Context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compression context.  <a href="structnvtt_1_1_context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html">Surface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A surface is one level of a 2D or 3D texture.  <a href="structnvtt_1_1_surface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface_set.html">SurfaceSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Surface-set struct for convenience of handling multi-level texture files such as DDS, currently only supporting reading.  <a href="structnvtt_1_1_surface_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_cube_surface.html">CubeSurface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="structnvtt_1_1_cube_surface.html" title="A CubeSurface is one level of a cube map texture.">CubeSurface</a> is one level of a cube map texture.  <a href="structnvtt_1_1_cube_surface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_batch_list.html">BatchList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure defining a list of inputs to be compressed.  <a href="structnvtt_1_1_batch_list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="structnvtt_1_1_timing_context.html" title="A TimingContext is a way to collect timing data from a number of functions, and report how much time ...">TimingContext</a> is a way to collect timing data from a number of functions, and report how much time each function took.  <a href="structnvtt_1_1_timing_context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_ref_image.html">RefImage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this structure to reference each of the input images.  <a href="structnvtt_1_1_ref_image.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure containing all the input images from host memory. The image data is reordered by tiles.  <a href="structnvtt_1_1_c_p_u_input_buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure containing all the input images from device memory. The image data is reordered by tiles.  <a href="structnvtt_1_1_g_p_u_input_buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_encode_settings.html">EncodeSettings</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a33b8617801c04cfe11ea9502eabdd892"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a33b8617801c04cfe11ea9502eabdd892">MessageCallback</a>) (<a class="el" href="namespacenvtt.html#a4e52ab92a29b129b3b6c39c762940eae">Severity</a> severity, <a class="el" href="namespacenvtt.html#ad1b50bb1a5bd8c44ab56092b30b9cd36">Error</a> error, const char *message, const void *userData)</td></tr>
<tr class="separator:a33b8617801c04cfe11ea9502eabdd892"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a04c40c16cdcde3c6c3f2e7081777a146"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a04c40c16cdcde3c6c3f2e7081777a146">WrapMode</a> { <a class="el" href="namespacenvtt.html#a04c40c16cdcde3c6c3f2e7081777a146ad11969ec5e66b90e4c7c55a2aa2542f0">WrapMode_Clamp</a>
, <a class="el" href="namespacenvtt.html#a04c40c16cdcde3c6c3f2e7081777a146aa974b2999b7a9ca5a0cbf5ebf52ecea9">WrapMode_Repeat</a>
, <a class="el" href="namespacenvtt.html#a04c40c16cdcde3c6c3f2e7081777a146a550cb72f50d0b0571a2db0badfb44083">WrapMode_Mirror</a>
 }</td></tr>
<tr class="memdesc:a04c40c16cdcde3c6c3f2e7081777a146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap modes. Specifies how to handle coordinates outside the typical image range.  <a href="namespacenvtt.html#a04c40c16cdcde3c6c3f2e7081777a146">More...</a><br /></td></tr>
<tr class="separator:a04c40c16cdcde3c6c3f2e7081777a146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22da3a04bb7324cbd3919166b678b8e2"><td class="memItemLeft" align="right" valign="top"><a id="a22da3a04bb7324cbd3919166b678b8e2"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a22da3a04bb7324cbd3919166b678b8e2">TextureType</a> { <b>TextureType_2D</b>
, <b>TextureType_Cube</b>
, <b>TextureType_3D</b>
 }</td></tr>
<tr class="memdesc:a22da3a04bb7324cbd3919166b678b8e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Texture types. Specifies the dimensionality of a texture. <br /></td></tr>
<tr class="separator:a22da3a04bb7324cbd3919166b678b8e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea4cd82d5104d66e14f5524442c5f5e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a7ea4cd82d5104d66e14f5524442c5f5e">InputFormat</a> { <br />
&#160;&#160;<a class="el" href="namespacenvtt.html#a7ea4cd82d5104d66e14f5524442c5f5eaf8b3af0719535e2e45599d0b20a463d2">InputFormat_BGRA_8UB</a>
, <a class="el" href="namespacenvtt.html#a7ea4cd82d5104d66e14f5524442c5f5ea2fcc1076f7eb98eb300757660fa8de07">InputFormat_BGRA_8SB</a>
, <a class="el" href="namespacenvtt.html#a7ea4cd82d5104d66e14f5524442c5f5ea351131926eee5bf0c0d0ed706699e2f0">InputFormat_RGBA_16F</a>
, <a class="el" href="namespacenvtt.html#a7ea4cd82d5104d66e14f5524442c5f5ea5c06b40c2edcfb0c948ebdc003c55a17">InputFormat_RGBA_32F</a>
, <br />
&#160;&#160;<a class="el" href="namespacenvtt.html#a7ea4cd82d5104d66e14f5524442c5f5ea7d8245786e1f39d2a9b8fb6baa2005c8">InputFormat_R_32F</a>
<br />
 }</td></tr>
<tr class="memdesc:a7ea4cd82d5104d66e14f5524442c5f5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input formats. Used when creating an <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">nvtt::Surface</a> from an RGB/RGBA array.  <a href="namespacenvtt.html#a7ea4cd82d5104d66e14f5524442c5f5e">More...</a><br /></td></tr>
<tr class="separator:a7ea4cd82d5104d66e14f5524442c5f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d4701da3f4e6935956949dab69c479"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a28d4701da3f4e6935956949dab69c479">MipmapFilter</a> { <a class="el" href="namespacenvtt.html#a28d4701da3f4e6935956949dab69c479a5aed6ac6d80b602d7bd7d8fd2d977697">MipmapFilter_Box</a>
, <a class="el" href="namespacenvtt.html#a28d4701da3f4e6935956949dab69c479a484a5118a16886793c921a3f17c04a2c">MipmapFilter_Triangle</a>
, <a class="el" href="namespacenvtt.html#a28d4701da3f4e6935956949dab69c479ae4a53887c8ee06fd999f022eefa29c5e">MipmapFilter_Kaiser</a>
 }</td></tr>
<tr class="memdesc:a28d4701da3f4e6935956949dab69c479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mipmap downsampling filters. Each of these can be customized using <code>filterWidth</code> and <code>params</code> when calling Surface::buildNextMipmap().  <a href="namespacenvtt.html#a28d4701da3f4e6935956949dab69c479">More...</a><br /></td></tr>
<tr class="separator:a28d4701da3f4e6935956949dab69c479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3607100ce561fdaa3859abd0f05878c7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a3607100ce561fdaa3859abd0f05878c7">ResizeFilter</a> { <a class="el" href="namespacenvtt.html#a3607100ce561fdaa3859abd0f05878c7ac608b4be1bb223cfd73e5aac2a002019">ResizeFilter_Box</a>
, <a class="el" href="namespacenvtt.html#a3607100ce561fdaa3859abd0f05878c7a86e98691c89dc3a4cd0b24bb2fd173cd">ResizeFilter_Triangle</a>
, <a class="el" href="namespacenvtt.html#a3607100ce561fdaa3859abd0f05878c7a6765919b82bb52e3384cd3b164347962">ResizeFilter_Kaiser</a>
, <a class="el" href="namespacenvtt.html#a3607100ce561fdaa3859abd0f05878c7ae014671bd84ab8296e2f1550f6afd7ee">ResizeFilter_Mitchell</a>
 }</td></tr>
<tr class="memdesc:a3607100ce561fdaa3859abd0f05878c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Texture resizing filters.  <a href="namespacenvtt.html#a3607100ce561fdaa3859abd0f05878c7">More...</a><br /></td></tr>
<tr class="separator:a3607100ce561fdaa3859abd0f05878c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a673a22796ec42ae50e14ab1ed6906bd5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a673a22796ec42ae50e14ab1ed6906bd5">RoundMode</a> { <a class="el" href="namespacenvtt.html#a673a22796ec42ae50e14ab1ed6906bd5ae8a8417fa16eb6d657bec4a6a34a4eb5">RoundMode_None</a>
, <a class="el" href="namespacenvtt.html#a673a22796ec42ae50e14ab1ed6906bd5a6c20fa585fc05a9fa78907cb75fd192e">RoundMode_ToNextPowerOfTwo</a>
, <a class="el" href="namespacenvtt.html#a673a22796ec42ae50e14ab1ed6906bd5a62447741e676e7442edfa9a160f14be0">RoundMode_ToNearestPowerOfTwo</a>
, <a class="el" href="namespacenvtt.html#a673a22796ec42ae50e14ab1ed6906bd5aa11b8ae64e7890e5037d6984b96d14a5">RoundMode_ToPreviousPowerOfTwo</a>
 }</td></tr>
<tr class="memdesc:a673a22796ec42ae50e14ab1ed6906bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extents rounding mode.  <a href="namespacenvtt.html#a673a22796ec42ae50e14ab1ed6906bd5">More...</a><br /></td></tr>
<tr class="separator:a673a22796ec42ae50e14ab1ed6906bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a258d3a85ebeb5cf05c98ce3b2441b172"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a258d3a85ebeb5cf05c98ce3b2441b172">AlphaMode</a> { <a class="el" href="namespacenvtt.html#a258d3a85ebeb5cf05c98ce3b2441b172a80b3682c42eec9a6dbc246872054c65a">AlphaMode_None</a>
, <a class="el" href="namespacenvtt.html#a258d3a85ebeb5cf05c98ce3b2441b172ab064a6344180e25b06ff1e7cb7863d76">AlphaMode_Transparency</a>
, <a class="el" href="namespacenvtt.html#a258d3a85ebeb5cf05c98ce3b2441b172a1e907653d2f7ea2020bd95938aa17694">AlphaMode_Premultiplied</a>
 }</td></tr>
<tr class="memdesc:a258d3a85ebeb5cf05c98ce3b2441b172"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alpha mode.  <a href="namespacenvtt.html#a258d3a85ebeb5cf05c98ce3b2441b172">More...</a><br /></td></tr>
<tr class="separator:a258d3a85ebeb5cf05c98ce3b2441b172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b50bb1a5bd8c44ab56092b30b9cd36"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#ad1b50bb1a5bd8c44ab56092b30b9cd36">Error</a> { <br />
&#160;&#160;<a class="el" href="namespacenvtt.html#ad1b50bb1a5bd8c44ab56092b30b9cd36a6a363ba70afc161ff85a7a52c3d92bbb">Error_None</a>
, <a class="el" href="namespacenvtt.html#ad1b50bb1a5bd8c44ab56092b30b9cd36aeb5d8ad9e386b13229cabf5ba1405475">Error_Unknown</a> = Error_None
, <a class="el" href="namespacenvtt.html#ad1b50bb1a5bd8c44ab56092b30b9cd36a7ae62389be2e2e29a7a1690b8721c105">Error_InvalidInput</a>
, <a class="el" href="namespacenvtt.html#ad1b50bb1a5bd8c44ab56092b30b9cd36a0c76f5e3b3d2b2ab2dae1c3b7bd291e6">Error_UnsupportedFeature</a>
, <br />
&#160;&#160;<a class="el" href="namespacenvtt.html#ad1b50bb1a5bd8c44ab56092b30b9cd36a61ea8e163d282921fbb20d9c6d165c6a">Error_CudaError</a>
, <a class="el" href="namespacenvtt.html#ad1b50bb1a5bd8c44ab56092b30b9cd36a050e9ac65add6839c261409762f63e60">Error_FileOpen</a>
, <a class="el" href="namespacenvtt.html#ad1b50bb1a5bd8c44ab56092b30b9cd36a272b79737f04552ad274898397e73f45">Error_FileWrite</a>
, <a class="el" href="namespacenvtt.html#ad1b50bb1a5bd8c44ab56092b30b9cd36aab5dbcdd40172c02fce91bf18ac46f36">Error_UnsupportedOutputFormat</a>
, <br />
&#160;&#160;<a class="el" href="namespacenvtt.html#ad1b50bb1a5bd8c44ab56092b30b9cd36a543f509e1a5e4b9955640b587d0533e4">Error_Messaging</a>
, <a class="el" href="namespacenvtt.html#ad1b50bb1a5bd8c44ab56092b30b9cd36aff7d46df90c539ac4e5b3e644e369dda">Error_OutOfHostMemory</a>
, <a class="el" href="namespacenvtt.html#ad1b50bb1a5bd8c44ab56092b30b9cd36adab9e4b4c47bbf76ceddb32a23c99361">Error_OutOfDeviceMemory</a>
, <a class="el" href="namespacenvtt.html#ad1b50bb1a5bd8c44ab56092b30b9cd36ac0464ea6704860307af9193e8f490d67">Error_OutputWrite</a>
, <br />
&#160;&#160;<b>Error_Count</b>
<br />
 }</td></tr>
<tr class="memdesc:ad1b50bb1a5bd8c44ab56092b30b9cd36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error codes.  <a href="namespacenvtt.html#ad1b50bb1a5bd8c44ab56092b30b9cd36">More...</a><br /></td></tr>
<tr class="separator:ad1b50bb1a5bd8c44ab56092b30b9cd36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e52ab92a29b129b3b6c39c762940eae"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a4e52ab92a29b129b3b6c39c762940eae">Severity</a> { <a class="el" href="namespacenvtt.html#a4e52ab92a29b129b3b6c39c762940eaeaf30f258dc0a2d3cd025d126a673ed6f3">Severity_Info</a>
, <a class="el" href="namespacenvtt.html#a4e52ab92a29b129b3b6c39c762940eaea4c6473576ef788248f30255258261995">Severity_Warning</a>
, <a class="el" href="namespacenvtt.html#a4e52ab92a29b129b3b6c39c762940eaea3727c52fc9062fd5292ef91ff85e3a46">Severity_Error</a>
, <b>Severity_Count</b>
 }</td></tr>
<tr class="memdesc:a4e52ab92a29b129b3b6c39c762940eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Message severity.  <a href="namespacenvtt.html#a4e52ab92a29b129b3b6c39c762940eae">More...</a><br /></td></tr>
<tr class="separator:a4e52ab92a29b129b3b6c39c762940eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ed02f7a03884673704a40ee13c7ea2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#ad6ed02f7a03884673704a40ee13c7ea2">Container</a> { <a class="el" href="namespacenvtt.html#ad6ed02f7a03884673704a40ee13c7ea2a0c37a8f503505acc0f2386d25f54ab02">Container_DDS</a>
, <a class="el" href="namespacenvtt.html#ad6ed02f7a03884673704a40ee13c7ea2a5a7d40cb9ce3544bf6c17fa93638abd0">Container_DDS10</a>
 }</td></tr>
<tr class="memdesc:ad6ed02f7a03884673704a40ee13c7ea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container type for encoded data.  <a href="namespacenvtt.html#ad6ed02f7a03884673704a40ee13c7ea2">More...</a><br /></td></tr>
<tr class="separator:ad6ed02f7a03884673704a40ee13c7ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a445e3b46e43013ef66771e98f7b1e0ba"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a445e3b46e43013ef66771e98f7b1e0ba">NormalTransform</a> { <a class="el" href="namespacenvtt.html#a445e3b46e43013ef66771e98f7b1e0baa7a435baa677e410f036ae06441229333">NormalTransform_Orthographic</a>
, <a class="el" href="namespacenvtt.html#a445e3b46e43013ef66771e98f7b1e0baac7ed9d9e81f80b4e11e1f53ab4f6f0f9">NormalTransform_Stereographic</a>
, <a class="el" href="namespacenvtt.html#a445e3b46e43013ef66771e98f7b1e0baa80b2a507b4e75a1febccfb2044cd86c8">NormalTransform_Paraboloid</a>
, <a class="el" href="namespacenvtt.html#a445e3b46e43013ef66771e98f7b1e0baa99c18c7689a8117272ab957e3bd78a4a">NormalTransform_Quartic</a>
 }</td></tr>
<tr class="memdesc:a445e3b46e43013ef66771e98f7b1e0ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a normal transformation, used to store 3D (x, y, z) normals in 2D (x, y).  <a href="namespacenvtt.html#a445e3b46e43013ef66771e98f7b1e0ba">More...</a><br /></td></tr>
<tr class="separator:a445e3b46e43013ef66771e98f7b1e0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30709ef62a9d666f2be7f34cce8e3b94"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a30709ef62a9d666f2be7f34cce8e3b94">ToneMapper</a> { <br />
&#160;&#160;<a class="el" href="namespacenvtt.html#a30709ef62a9d666f2be7f34cce8e3b94ae75755a83e2455024daa028f9997e142">ToneMapper_Linear</a>
, <a class="el" href="namespacenvtt.html#a30709ef62a9d666f2be7f34cce8e3b94a4eac0b21fc9b9abaa609aaccbc8b692d">ToneMapper_Reinhard</a>
, <a class="el" href="namespacenvtt.html#a30709ef62a9d666f2be7f34cce8e3b94ae212ae6b6b95ef74d99e8c294f0582a4">ToneMapper_Reindhart</a> = ToneMapper_Reinhard
, <a class="el" href="namespacenvtt.html#a30709ef62a9d666f2be7f34cce8e3b94a88b4b1bc1882ee68b7148e3e36fe155f">ToneMapper_Halo</a>
, <br />
&#160;&#160;<a class="el" href="namespacenvtt.html#a30709ef62a9d666f2be7f34cce8e3b94ab9ee3d3f346369d1097532952c3f0baf">ToneMapper_Lightmap</a>
<br />
 }</td></tr>
<tr class="memdesc:a30709ef62a9d666f2be7f34cce8e3b94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tone mapping functions.  <a href="namespacenvtt.html#a30709ef62a9d666f2be7f34cce8e3b94">More...</a><br /></td></tr>
<tr class="separator:a30709ef62a9d666f2be7f34cce8e3b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a447d53023355eb2e39e3e9a9a9b9d8dc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a447d53023355eb2e39e3e9a9a9b9d8dc">CubeLayout</a> { <br />
&#160;&#160;<a class="el" href="namespacenvtt.html#a447d53023355eb2e39e3e9a9a9b9d8dca707896e6ec737f4b3a763146d7b33702">CubeLayout_VerticalCross</a>
, <a class="el" href="namespacenvtt.html#a447d53023355eb2e39e3e9a9a9b9d8dca3fb7abb18cf90ada89e7285dc1f03422">CubeLayout_HorizontalCross</a>
, <a class="el" href="namespacenvtt.html#a447d53023355eb2e39e3e9a9a9b9d8dca24b818d2b111932259f02aa69b52973a">CubeLayout_Column</a>
, <a class="el" href="namespacenvtt.html#a447d53023355eb2e39e3e9a9a9b9d8dca24e62c1313b8ffe4c6ddc01aef5727df">CubeLayout_Row</a>
, <br />
&#160;&#160;<a class="el" href="namespacenvtt.html#a447d53023355eb2e39e3e9a9a9b9d8dcabf6eed2e38bb04ec6e660b136fede3da">CubeLayout_LatitudeLongitude</a>
<br />
 }</td></tr>
<tr class="memdesc:a447d53023355eb2e39e3e9a9a9b9d8dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies how to fold or unfold a cube map from or to a 2D texture.  <a href="namespacenvtt.html#a447d53023355eb2e39e3e9a9a9b9d8dc">More...</a><br /></td></tr>
<tr class="separator:a447d53023355eb2e39e3e9a9a9b9d8dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acffe2adb946ca4eeae692ef547d57ca6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#acffe2adb946ca4eeae692ef547d57ca6">EdgeFixup</a> { <a class="el" href="namespacenvtt.html#acffe2adb946ca4eeae692ef547d57ca6affcf62e8e27e7351dce5c92908419767">EdgeFixup_None</a>
, <a class="el" href="namespacenvtt.html#acffe2adb946ca4eeae692ef547d57ca6aeda3d9a01b5bcf73994c5ebcc52c62d5">EdgeFixup_Stretch</a>
, <a class="el" href="namespacenvtt.html#acffe2adb946ca4eeae692ef547d57ca6abbcabb8211cceed5c1074b98d8575e4b">EdgeFixup_Warp</a>
, <a class="el" href="namespacenvtt.html#acffe2adb946ca4eeae692ef547d57ca6a424f99e9f5ca67b49765dec421c8c27f">EdgeFixup_Average</a>
 }</td></tr>
<tr class="memdesc:acffe2adb946ca4eeae692ef547d57ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use EdgeFixup_None if unsure; this affects how certain cube surface processing algorithms work.  <a href="namespacenvtt.html#acffe2adb946ca4eeae692ef547d57ca6">More...</a><br /></td></tr>
<tr class="separator:acffe2adb946ca4eeae692ef547d57ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae939a4f095a98e5176153b81dba28321"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#ae939a4f095a98e5176153b81dba28321">ValueType</a> { <a class="el" href="namespacenvtt.html#ae939a4f095a98e5176153b81dba28321a2af64236612722b24eb2b58858257b4b">UINT8</a>
, <a class="el" href="namespacenvtt.html#ae939a4f095a98e5176153b81dba28321a138041050ea3405a6c150a8814446720">SINT8</a>
, <a class="el" href="namespacenvtt.html#ae939a4f095a98e5176153b81dba28321aeadcb5f215901bc412fe1f946c4f460a">FLOAT32</a>
, <a class="el" href="namespacenvtt.html#ae939a4f095a98e5176153b81dba28321a69cb5de6a59e2c359b3aa9eae0d1ba86">FLOAT16</a>
 }</td></tr>
<tr class="separator:ae939a4f095a98e5176153b81dba28321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a069e6423013efdad8fef5221e4266aba"><td class="memItemLeft" align="right" valign="top"><a id="a069e6423013efdad8fef5221e4266aba"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a069e6423013efdad8fef5221e4266aba">ChannelOrder</a> { <br />
&#160;&#160;<b>Red</b> = 0
, <b>Green</b> = 1
, <b>Blue</b> = 2
, <b>Alpha</b> = 3
, <br />
&#160;&#160;<b>Zero</b> = 4
, <b>One</b> = 5
<br />
 }</td></tr>
<tr class="memdesc:a069e6423013efdad8fef5221e4266aba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of channels for defining a swizzling. <br /></td></tr>
<tr class="separator:a069e6423013efdad8fef5221e4266aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ad50b0ef658f079f5ec637a287fd6d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6d">Format</a> { <br />
&#160;&#160;<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6dad70b3a5abe17d4e6cc1a731e4bee76a6">Format_RGB</a>
, <a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6da1e4b5108b4c89f805f2efafd826b03d3">Format_RGBA</a> = Format_RGB
, <a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6da9ca8e3f8d05a0fae928ae309608ef722">Format_DXT1</a>
, <a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6dad074d39474c02c1d4171d2545e3968b1">Format_DXT1a</a>
, <br />
&#160;&#160;<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6dac40dd2ca7ea53576720b7c20e1704312">Format_DXT3</a>
, <a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6daa2bd0a4fcc15b2a692a6d8929a43e4d3">Format_DXT5</a>
, <a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6dae15335efd54def95c6df709b3f020999">Format_DXT5n</a>
, <a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6da7eb461737e0fc882a93255789c7cadec">Format_BC1</a> = Format_DXT1
, <br />
&#160;&#160;<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6dad251519ccb2dcda1bc41e7cd1b2e1c4c">Format_BC1a</a> = Format_DXT1a
, <a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6da0b504e386c28119b49c6064a64452d66">Format_BC2</a> = Format_DXT3
, <a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6dac8ee0455899fe6fde42300df20aaf282">Format_BC3</a> = Format_DXT5
, <a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6da841bbc25f933d81b4a43c851c5440c64">Format_BC3n</a> = Format_DXT5n
, <br />
&#160;&#160;<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6dadc47f6b455d3533d5d3bc7abd231a2fb">Format_BC4</a>
, <a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6daf01d343dcafe84c2084a5a86344bf1db">Format_BC4S</a>
, <a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6dab368e55b0d5dbffa54861a62db699526">Format_ATI2</a>
, <a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6da7e53438784904c341ff65d3ed8bac4af">Format_BC5</a>
, <br />
&#160;&#160;<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6dade3eb3f3d00102653de87f48a4c53b45">Format_BC5S</a>
, <a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6dabf6dd404c065d8d9aa35266241771f80">Format_DXT1n</a>
, <a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6dafae7a3d4517b2e6bb9ffc3b30c35112d">Format_CTX1</a>
, <a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6da53a0a422d27f650216141a2b69419972">Format_BC6U</a>
, <br />
&#160;&#160;<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6da57afee5146cfce8914252efe38ee69af">Format_BC6S</a>
, <a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6da7504a001d01a2e3f1cda648f1e32676b">Format_BC7</a>
, <a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6da3623a3b6e315c7cd908dd4ea78b68c58">Format_BC3_RGBM</a>
, <a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6dacd61083f3787f211cdc3e7d27acf0bcb">Format_ASTC_LDR_4x4</a>
, <br />
&#160;&#160;<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6daa462932902c3804af0974ea419728caa">Format_ASTC_LDR_5x4</a>
, <a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6da69fa601cd97b38a974ad5a94a1f3f9a4">Format_ASTC_LDR_5x5</a>
, <a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6dae16bc6c24bb5c12f5b1bdfcfda621e49">Format_ASTC_LDR_6x5</a>
, <a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6da7eaa6f0a5231f4803526021a8706578c">Format_ASTC_LDR_6x6</a>
, <br />
&#160;&#160;<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6da3a68b29ecfa982cccc6767d6689f0a5a">Format_ASTC_LDR_8x5</a>
, <a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6dab7f9c4ca1719ae5e4eceb3ce0a2f8901">Format_ASTC_LDR_8x6</a>
, <a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6dae931d404efcdffa4b2dbabf9fdf54228">Format_ASTC_LDR_8x8</a>
, <a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6da697ca508a97e9e064f7434863e39f41e">Format_ASTC_LDR_10x5</a>
, <br />
&#160;&#160;<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6da7625882a2047accb75e68e3c3aa10ccf">Format_ASTC_LDR_10x6</a>
, <a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6da4c8c8b6ec09ff02cc4f3802b79ace3e0">Format_ASTC_LDR_10x8</a>
, <a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6daf8842b25b9be7ace43116e155dcd18a6">Format_ASTC_LDR_10x10</a>
, <a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6da8aae371759244af41fe3e77e7a904d10">Format_ASTC_LDR_12x10</a>
, <br />
&#160;&#160;<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6dac03f729d1aede99d35414fd9b524a41a">Format_ASTC_LDR_12x12</a>
, <b>Format_Count</b>
, <a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6dadc0b2bd1f884f91c596956d8631bb8c6">Format_Unset</a> = 255
<br />
 }</td></tr>
<tr class="memdesc:a77ad50b0ef658f079f5ec637a287fd6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported block-compression formats, including compressor variants.  <a href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6d">More...</a><br /></td></tr>
<tr class="separator:a77ad50b0ef658f079f5ec637a287fd6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accbc2d4c0396fc4e6d75d19e435c88ed"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#accbc2d4c0396fc4e6d75d19e435c88ed">PixelType</a> { <br />
&#160;&#160;<a class="el" href="namespacenvtt.html#accbc2d4c0396fc4e6d75d19e435c88eda36283fd855802ab127337a9204a1abac">PixelType_UnsignedNorm</a> = 0
, <a class="el" href="namespacenvtt.html#accbc2d4c0396fc4e6d75d19e435c88edac5f45ced167de5441252bb48cedaae11">PixelType_SignedNorm</a> = 1
, <a class="el" href="namespacenvtt.html#accbc2d4c0396fc4e6d75d19e435c88eda6f44a7d0693e3706916061221bc76724">PixelType_UnsignedInt</a> = 2
, <a class="el" href="namespacenvtt.html#accbc2d4c0396fc4e6d75d19e435c88eda86f04728921c58b535e40d9b4e156123">PixelType_SignedInt</a> = 3
, <br />
&#160;&#160;<a class="el" href="namespacenvtt.html#accbc2d4c0396fc4e6d75d19e435c88eda83f9ceb43bd9b001b835e39f08111db3">PixelType_Float</a> = 4
, <a class="el" href="namespacenvtt.html#accbc2d4c0396fc4e6d75d19e435c88edab8107297b020c703bc308794cbbdf6d5">PixelType_UnsignedFloat</a> = 5
, <a class="el" href="namespacenvtt.html#accbc2d4c0396fc4e6d75d19e435c88edabb4c7c8a272083c0b14c7f8fdbf4f77b">PixelType_SharedExp</a> = 6
<br />
 }</td></tr>
<tr class="memdesc:accbc2d4c0396fc4e6d75d19e435c88ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pixel value types.  <a href="namespacenvtt.html#accbc2d4c0396fc4e6d75d19e435c88ed">More...</a><br /></td></tr>
<tr class="separator:accbc2d4c0396fc4e6d75d19e435c88ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a4632cb59f63e6af3fc88fdfe5e44ee"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a5a4632cb59f63e6af3fc88fdfe5e44ee">Quality</a> { <b>Quality_Fastest</b>
, <b>Quality_Normal</b>
, <b>Quality_Production</b>
, <b>Quality_Highest</b>
 }</td></tr>
<tr class="memdesc:a5a4632cb59f63e6af3fc88fdfe5e44ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quality modes.  <a href="namespacenvtt.html#a5a4632cb59f63e6af3fc88fdfe5e44ee">More...</a><br /></td></tr>
<tr class="separator:a5a4632cb59f63e6af3fc88fdfe5e44ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88aa620b06c95f24957941e3bf64519b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a88aa620b06c95f24957941e3bf64519b">EncodeFlags</a> : uint32_t { <b>EncodeFlags_None</b> = 0
, <a class="el" href="namespacenvtt.html#a88aa620b06c95f24957941e3bf64519ba81edab19a33ab5c3de43b8fd16517dbb">EncodeFlags_UseGPU</a> = 1 &lt;&lt; 0
, <a class="el" href="namespacenvtt.html#a88aa620b06c95f24957941e3bf64519ba2488c64c79e82ba5d3f8ebc2ff22d1dc">EncodeFlags_OutputToGPUMem</a> = 1 &lt;&lt; 1
, <a class="el" href="namespacenvtt.html#a88aa620b06c95f24957941e3bf64519ba29d2523dd83ce311a5184da0b625ebcd">EncodeFlags_Opaque</a> = 1 &lt;&lt; 2
 }</td></tr>
<tr class="memdesc:a88aa620b06c95f24957941e3bf64519b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode flags for EncodeSettings.  <a href="namespacenvtt.html#a88aa620b06c95f24957941e3bf64519b">More...</a><br /></td></tr>
<tr class="separator:a88aa620b06c95f24957941e3bf64519b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a228e276da2093484610fa62a9ec4ee93"><td class="memItemLeft" align="right" valign="top"><a id="a228e276da2093484610fa62a9ec4ee93"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a228e276da2093484610fa62a9ec4ee93">version</a> ()</td></tr>
<tr class="memdesc:a228e276da2093484610fa62a9ec4ee93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the NVTT version number, as 10000*major + 100*minor + maintenance. <br /></td></tr>
<tr class="separator:a228e276da2093484610fa62a9ec4ee93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1ae97a643706ccf2940c94e3ca622fd"><td class="memItemLeft" align="right" valign="top"><a id="aa1ae97a643706ccf2940c94e3ca622fd"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#aa1ae97a643706ccf2940c94e3ca622fd">errorString</a> (<a class="el" href="namespacenvtt.html#ad1b50bb1a5bd8c44ab56092b30b9cd36">Error</a> e)</td></tr>
<tr class="memdesc:aa1ae97a643706ccf2940c94e3ca622fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return string for the given error code. <br /></td></tr>
<tr class="separator:aa1ae97a643706ccf2940c94e3ca622fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b365e96db619c235d9b5e5907c78ac3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a9b365e96db619c235d9b5e5907c78ac3">setMessageCallback</a> (<a class="el" href="namespacenvtt.html#a33b8617801c04cfe11ea9502eabdd892">MessageCallback</a> callback, const void *userData)</td></tr>
<tr class="separator:a9b365e96db619c235d9b5e5907c78ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a3afaec760ccfaddbc0d41a30ea3b4"><td class="memItemLeft" align="right" valign="top"><a id="ad5a3afaec760ccfaddbc0d41a30ea3b4"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#ad5a3afaec760ccfaddbc0d41a30ea3b4">rmsError</a> (const <a class="el" href="structnvtt_1_1_surface.html">Surface</a> &amp;reference, const <a class="el" href="structnvtt_1_1_surface.html">Surface</a> &amp;img, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:ad5a3afaec760ccfaddbc0d41a30ea3b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Image comparison and error measurement functions. (New in NVTT 2.1) <br /></td></tr>
<tr class="separator:ad5a3afaec760ccfaddbc0d41a30ea3b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b64d4539ee2f98379249975d2b277c"><td class="memItemLeft" align="right" valign="top"><a id="a91b64d4539ee2f98379249975d2b277c"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a91b64d4539ee2f98379249975d2b277c">rmsAlphaError</a> (const <a class="el" href="structnvtt_1_1_surface.html">Surface</a> &amp;reference, const <a class="el" href="structnvtt_1_1_surface.html">Surface</a> &amp;img, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a91b64d4539ee2f98379249975d2b277c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Image comparison and error measurement functions. (New in NVTT 2.1) <br /></td></tr>
<tr class="separator:a91b64d4539ee2f98379249975d2b277c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e0978c5e0f8676cc591d2efdb782e9"><td class="memItemLeft" align="right" valign="top"><a id="a21e0978c5e0f8676cc591d2efdb782e9"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a21e0978c5e0f8676cc591d2efdb782e9">cieLabError</a> (const <a class="el" href="structnvtt_1_1_surface.html">Surface</a> &amp;reference, const <a class="el" href="structnvtt_1_1_surface.html">Surface</a> &amp;img, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a21e0978c5e0f8676cc591d2efdb782e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Image comparison and error measurement functions. (New in NVTT 2.1) <br /></td></tr>
<tr class="separator:a21e0978c5e0f8676cc591d2efdb782e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc944623c193bb0a1f8679a6f44a78e5"><td class="memItemLeft" align="right" valign="top"><a id="abc944623c193bb0a1f8679a6f44a78e5"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#abc944623c193bb0a1f8679a6f44a78e5">angularError</a> (const <a class="el" href="structnvtt_1_1_surface.html">Surface</a> &amp;reference, const <a class="el" href="structnvtt_1_1_surface.html">Surface</a> &amp;img, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:abc944623c193bb0a1f8679a6f44a78e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Image comparison and error measurement functions. (New in NVTT 2.1) <br /></td></tr>
<tr class="separator:abc944623c193bb0a1f8679a6f44a78e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1781708d38918b6eda9165fb5f9c10c1"><td class="memItemLeft" align="right" valign="top"><a id="a1781708d38918b6eda9165fb5f9c10c1"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> <a class="el" href="structnvtt_1_1_surface.html">Surface</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a1781708d38918b6eda9165fb5f9c10c1">diff</a> (const <a class="el" href="structnvtt_1_1_surface.html">Surface</a> &amp;reference, const <a class="el" href="structnvtt_1_1_surface.html">Surface</a> &amp;img, float scale, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a1781708d38918b6eda9165fb5f9c10c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Image comparison and error measurement functions. (New in NVTT 2.1) <br /></td></tr>
<tr class="separator:a1781708d38918b6eda9165fb5f9c10c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37bcafcdac02a84ac84306a758276b39"><td class="memItemLeft" align="right" valign="top"><a id="a37bcafcdac02a84ac84306a758276b39"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a37bcafcdac02a84ac84306a758276b39">rmsToneMappedError</a> (const <a class="el" href="structnvtt_1_1_surface.html">Surface</a> &amp;reference, const <a class="el" href="structnvtt_1_1_surface.html">Surface</a> &amp;img, float exposure, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a37bcafcdac02a84ac84306a758276b39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Image comparison and error measurement functions. (New in NVTT 2.1) <br /></td></tr>
<tr class="separator:a37bcafcdac02a84ac84306a758276b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3181d618054f0b1591e01a342136b6b7"><td class="memItemLeft" align="right" valign="top"><a id="a3181d618054f0b1591e01a342136b6b7"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> <a class="el" href="structnvtt_1_1_surface.html">Surface</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a3181d618054f0b1591e01a342136b6b7">histogram</a> (const <a class="el" href="structnvtt_1_1_surface.html">Surface</a> &amp;img, int width, int height, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a3181d618054f0b1591e01a342136b6b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate histogram from surface. <br /></td></tr>
<tr class="separator:a3181d618054f0b1591e01a342136b6b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b39014308319e64f6cb72ee5b0219fe"><td class="memItemLeft" align="right" valign="top"><a id="a2b39014308319e64f6cb72ee5b0219fe"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> <a class="el" href="structnvtt_1_1_surface.html">Surface</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a2b39014308319e64f6cb72ee5b0219fe">histogram</a> (const <a class="el" href="structnvtt_1_1_surface.html">Surface</a> &amp;img, float minRange, float maxRange, int width, int height, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a2b39014308319e64f6cb72ee5b0219fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate histogram from surface. <br /></td></tr>
<tr class="separator:a2b39014308319e64f6cb72ee5b0219fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73aebd76a0eef81407c40b5b93ee7c10"><td class="memItemLeft" align="right" valign="top"><a id="a73aebd76a0eef81407c40b5b93ee7c10"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a73aebd76a0eef81407c40b5b93ee7c10">getTargetExtent</a> (int *width, int *height, int *depth, int maxExtent, <a class="el" href="namespacenvtt.html#a673a22796ec42ae50e14ab1ed6906bd5">RoundMode</a> roundMode, <a class="el" href="namespacenvtt.html#a22da3a04bb7324cbd3919166b678b8e2">TextureType</a> textureType, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a73aebd76a0eef81407c40b5b93ee7c10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Geting the target extent for round-mode and texture-type. (New in NVTT 3.0) <br /></td></tr>
<tr class="separator:a73aebd76a0eef81407c40b5b93ee7c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f0d070b80d740b949710df7e9ca361"><td class="memItemLeft" align="right" valign="top"><a id="ad3f0d070b80d740b949710df7e9ca361"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#ad3f0d070b80d740b949710df7e9ca361">countMipmaps</a> (int w, int h, int d, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:ad3f0d070b80d740b949710df7e9ca361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the count of mipmaps given width, height, depth. (New in NVTT 3.0) <br /></td></tr>
<tr class="separator:ad3f0d070b80d740b949710df7e9ca361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e1ba1bbab69167fca20f080ca9ce8e"><td class="memItemLeft" align="right" valign="top"><a id="a07e1ba1bbab69167fca20f080ca9ce8e"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a07e1ba1bbab69167fca20f080ca9ce8e">isCudaSupported</a> ()</td></tr>
<tr class="memdesc:a07e1ba1bbab69167fca20f080ca9ce8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if CUDA is supported by the run-time environment. <br /></td></tr>
<tr class="separator:a07e1ba1bbab69167fca20f080ca9ce8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4331c366610258762f80c8a3d7ee6910"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a4331c366610258762f80c8a3d7ee6910">useCurrentDevice</a> ()</td></tr>
<tr class="memdesc:a4331c366610258762f80c8a3d7ee6910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells NVTT to always use an application-set device rather than selecting its own.  <a href="namespacenvtt.html#a4331c366610258762f80c8a3d7ee6910">More...</a><br /></td></tr>
<tr class="separator:a4331c366610258762f80c8a3d7ee6910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ef44c2a4c9551980d0e85635a47e2a"><td class="memItemLeft" align="right" valign="top">bool <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a14ef44c2a4c9551980d0e85635a47e2a">nvtt_encode</a> (const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;input, void *output, const <a class="el" href="structnvtt_1_1_encode_settings.html">EncodeSettings</a> &amp;settings)</td></tr>
<tr class="separator:a14ef44c2a4c9551980d0e85635a47e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91dfb6d2042c4d5bcb1bb664bd87a42f"><td class="memItemLeft" align="right" valign="top">bool <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a91dfb6d2042c4d5bcb1bb664bd87a42f">nvtt_encode</a> (const <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a> &amp;input, void *output, const <a class="el" href="structnvtt_1_1_encode_settings.html">EncodeSettings</a> &amp;settings)</td></tr>
<tr class="separator:a91dfb6d2042c4d5bcb1bb664bd87a42f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05bd68f7ce315c0c26124793512bc6ed"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a05bd68f7ce315c0c26124793512bc6ed">nvtt_encode_bc1</a> (const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;input, bool fast_mode, void *output, bool useGpu=false, bool to_device_mem=false, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:a05bd68f7ce315c0c26124793512bc6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e0e41149b87bd6c5d3f327ac7a0a97"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#aa9e0e41149b87bd6c5d3f327ac7a0a97">nvtt_encode_bc1</a> (const <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a> &amp;input, bool fast_mode, void *output, bool to_device_mem=true, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:aa9e0e41149b87bd6c5d3f327ac7a0a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd3ed1c285fc5e6c146cc9de88937bb"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a5bd3ed1c285fc5e6c146cc9de88937bb">nvtt_encode_bc1a</a> (const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;input, bool fast_mode, void *output, bool useGpu=false, bool to_device_mem=false, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:a5bd3ed1c285fc5e6c146cc9de88937bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61eefb6c30a92e72d297f3bf2fe39f10"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a61eefb6c30a92e72d297f3bf2fe39f10">nvtt_encode_bc1a</a> (const <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a> &amp;input, void *output, bool to_device_mem=true, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:a61eefb6c30a92e72d297f3bf2fe39f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb08b8c7f7030e7473187ff5e986294f"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#abb08b8c7f7030e7473187ff5e986294f">nvtt_encode_bc2</a> (const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;input, bool fast_mode, void *output, bool useGpu=false, bool to_device_mem=false, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:abb08b8c7f7030e7473187ff5e986294f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae6bd44be0539af54582d5dd5aa88a1"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a2ae6bd44be0539af54582d5dd5aa88a1">nvtt_encode_bc2</a> (const <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a> &amp;input, void *output, bool to_device_mem=true, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:a2ae6bd44be0539af54582d5dd5aa88a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac335a276d5f79af2a762d76988e661ad"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#ac335a276d5f79af2a762d76988e661ad">nvtt_encode_bc3</a> (const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;input, bool fast_mode, void *output, bool useGpu=false, bool to_device_mem=false, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:ac335a276d5f79af2a762d76988e661ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad95872eab2e29b5b4a7721c4a2b961"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#aaad95872eab2e29b5b4a7721c4a2b961">nvtt_encode_bc3</a> (const <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a> &amp;input, void *output, bool to_device_mem=true, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:aaad95872eab2e29b5b4a7721c4a2b961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82056d5ee5c0f852135d8cd6bab149e"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#ab82056d5ee5c0f852135d8cd6bab149e">nvtt_encode_bc3n</a> (const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;input, int qualityLevel, void *output, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:ab82056d5ee5c0f852135d8cd6bab149e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad69901604f7f6e6e1acb0486ad5db001"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#ad69901604f7f6e6e1acb0486ad5db001">nvtt_encode_bc3_rgbm</a> (const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;input, void *output, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:ad69901604f7f6e6e1acb0486ad5db001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c370ed199a91ca69c4c01c9f6daed39"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a7c370ed199a91ca69c4c01c9f6daed39">nvtt_encode_bc4</a> (const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;input, bool slow_mode, void *output, bool useGpu=false, bool to_device_mem=false, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:a7c370ed199a91ca69c4c01c9f6daed39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76314c0b925a24e3f509e4a212668ae"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#aa76314c0b925a24e3f509e4a212668ae">nvtt_encode_bc4</a> (const <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a> &amp;input, void *output, bool to_device_mem=true, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:aa76314c0b925a24e3f509e4a212668ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15a4c506eb1c3b5ad89249ef3e8e340"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#ab15a4c506eb1c3b5ad89249ef3e8e340">nvtt_encode_bc4s</a> (const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;input, bool slow_mode, void *output, bool useGpu=false, bool to_device_mem=false, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:ab15a4c506eb1c3b5ad89249ef3e8e340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e7a48139329817c6b6acc3ae875c03"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#ae3e7a48139329817c6b6acc3ae875c03">nvtt_encode_bc4s</a> (const <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a> &amp;input, void *output, bool to_device_mem=true, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:ae3e7a48139329817c6b6acc3ae875c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f678e13767228c68dfcad1da61e8b7d"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a2f678e13767228c68dfcad1da61e8b7d">nvtt_encode_ati2</a> (const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;input, bool slow_mode, void *output, bool useGpu=false, bool to_device_mem=false, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:a2f678e13767228c68dfcad1da61e8b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393f3f5de7cdefa79e31b095384b6e14"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a393f3f5de7cdefa79e31b095384b6e14">nvtt_encode_ati2</a> (const <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a> &amp;input, void *output, bool to_device_mem=true, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:a393f3f5de7cdefa79e31b095384b6e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c96f1d819b4c61b42d537c102080c32"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a0c96f1d819b4c61b42d537c102080c32">nvtt_encode_bc5</a> (const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;input, bool slow_mode, void *output, bool useGpu=false, bool to_device_mem=false, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:a0c96f1d819b4c61b42d537c102080c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dfc0444515b1304ab9a1cb6eb9ff5b8"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a3dfc0444515b1304ab9a1cb6eb9ff5b8">nvtt_encode_bc5</a> (const <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a> &amp;input, void *output, bool to_device_mem=true, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:a3dfc0444515b1304ab9a1cb6eb9ff5b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4d632aa6c550b8b461f4343125fe77"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a7e4d632aa6c550b8b461f4343125fe77">nvtt_encode_bc5s</a> (const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;input, bool slow_mode, void *output, bool useGpu=false, bool to_device_mem=false, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:a7e4d632aa6c550b8b461f4343125fe77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3ea7d013fca07b16f48745ad67b1e21"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#ac3ea7d013fca07b16f48745ad67b1e21">nvtt_encode_bc5s</a> (const <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a> &amp;input, void *output, bool to_device_mem=true, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:ac3ea7d013fca07b16f48745ad67b1e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc828476883ed40499d01622d2a0873f"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#adc828476883ed40499d01622d2a0873f">nvtt_encode_bc7</a> (const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;input, bool slow_mode, bool imageHasAlpha, void *output, bool useGpu=false, bool to_device_mem=false, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:adc828476883ed40499d01622d2a0873f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80dbdb09bbe3f2702bad846d90b69578"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a80dbdb09bbe3f2702bad846d90b69578">nvtt_encode_bc7</a> (const <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a> &amp;input, bool imageHasAlpha, void *output, bool to_device_mem=true, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:a80dbdb09bbe3f2702bad846d90b69578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd712c6a68534c161e2e20fa3967663"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#aebd712c6a68534c161e2e20fa3967663">nvtt_encode_bc6h</a> (const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;input, bool slow_mode, bool is_signed, void *output, bool useGpu=false, bool to_device_mem=false, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:aebd712c6a68534c161e2e20fa3967663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74857405343d8148e3aa8a840f5d9c1e"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a74857405343d8148e3aa8a840f5d9c1e">nvtt_encode_bc6h</a> (const <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a> &amp;input, bool is_signed, void *output, bool to_device_mem=true, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:a74857405343d8148e3aa8a840f5d9c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5eb0a19f8d66f6c9f5cf33f335c32f"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a3c5eb0a19f8d66f6c9f5cf33f335c32f">nvtt_encode_astc</a> (const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;input, int qualityLevel, bool imageHasAlpha, void *output, bool useGpu=false, bool to_device_mem=false, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:a3c5eb0a19f8d66f6c9f5cf33f335c32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b2a51a1949426c7f860c52c7561b97"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a25b2a51a1949426c7f860c52c7561b97">nvtt_encode_astc</a> (const <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a> &amp;input, int qualityLevel, bool imageHasAlpha, void *output, bool to_device_mem=true, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:a25b2a51a1949426c7f860c52c7561b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace for all public non-macro NVTT fields. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a33b8617801c04cfe11ea9502eabdd892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33b8617801c04cfe11ea9502eabdd892">&#9670;&nbsp;</a></span>MessageCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* nvtt::MessageCallback) (<a class="el" href="namespacenvtt.html#a4e52ab92a29b129b3b6c39c762940eae">Severity</a> severity, <a class="el" href="namespacenvtt.html#ad1b50bb1a5bd8c44ab56092b30b9cd36">Error</a> error, const char *message, const void *userData)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A MessageCallback is a function that takes a message <code>Severity</code>, an error enumeration (only nonzero for error messages), a null-terminated description of the message (usually with useful information for debugging; no newline at end), and a custom user pointer set when calling <code>nvtt::SetMessageCallback()</code>. </p><dl class="section since"><dt>Since</dt><dd>NVTT 3.2 </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a258d3a85ebeb5cf05c98ce3b2441b172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a258d3a85ebeb5cf05c98ce3b2441b172">&#9670;&nbsp;</a></span>AlphaMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenvtt.html#a258d3a85ebeb5cf05c98ce3b2441b172">nvtt::AlphaMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alpha mode. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a258d3a85ebeb5cf05c98ce3b2441b172a80b3682c42eec9a6dbc246872054c65a"></a>AlphaMode_None&#160;</td><td class="fielddoc"><p>This image has no alpha. The alpha channel will be ignored in some forms of compression. </p>
</td></tr>
<tr><td class="fieldname"><a id="a258d3a85ebeb5cf05c98ce3b2441b172ab064a6344180e25b06ff1e7cb7863d76"></a>AlphaMode_Transparency&#160;</td><td class="fielddoc"><p>Alpha represents opacity; for instance, (r, g, b, 0.5) is a 50% opaque (r, g, b) color. </p>
</td></tr>
<tr><td class="fieldname"><a id="a258d3a85ebeb5cf05c98ce3b2441b172a1e907653d2f7ea2020bd95938aa17694"></a>AlphaMode_Premultiplied&#160;</td><td class="fielddoc"><p>Colors are stored using premultiplied alpha: (a*r, a*g, a*b, a) is an (r, g, b) color with an opacity of a. This is mostly for tracking purposes; compressors only distinguish between AlphaMode_None and AlphaMode_Transparency. <br  />
 </p>
</td></tr>
</table>

</div>
</div>
<a id="ad6ed02f7a03884673704a40ee13c7ea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6ed02f7a03884673704a40ee13c7ea2">&#9670;&nbsp;</a></span>Container</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenvtt.html#ad6ed02f7a03884673704a40ee13c7ea2">nvtt::Container</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Container type for encoded data. </p>
<dl class="section note"><dt>Note</dt><dd>For DDS containers, NVTT stores some additional data in the <code>reserved[]</code> fields to allow consumers to detect writer versions.<ul>
<li><code>reserved[7]</code> is the FourCC code "UVER", and <code>reserved[8]</code> stores a version number that can be set by the user.</li>
<li><code>reserved[9]</code> is the FourCC code "NVTT", and <code>reserved[10]</code> is the NVTT writer version (which isn't necessarily the same as <code><a class="el" href="namespacenvtt.html#a228e276da2093484610fa62a9ec4ee93" title="Return the NVTT version number, as 10000*major + 100*minor + maintenance.">nvtt::version()</a></code>).</li>
</ul>
</dd>
<dd>
For DDS containers, NVTT also extends the <code>dwFlags</code> field with two more flags.<ul>
<li><code>DDPF_SRGB</code> (<code>0x40000000U</code>) indicates that the texture uses an sRGB transfer function. Note that most readers will ignore this and instead guess the transfer function from the format.</li>
<li><code>DDPF_NORMAL</code> (<code>0x80000000U</code>) indicates that the texture is a normal map. </li>
</ul>
</dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad6ed02f7a03884673704a40ee13c7ea2a0c37a8f503505acc0f2386d25f54ab02"></a>Container_DDS&#160;</td><td class="fielddoc"><p>DDS without the DX10 header extension. Compatible with legacy readers, but doesn't support BC6 or BC7. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad6ed02f7a03884673704a40ee13c7ea2a5a7d40cb9ce3544bf6c17fa93638abd0"></a>Container_DDS10&#160;</td><td class="fielddoc"><p>DDS without the DX10 header. Supports BC6 and BC7, but may be unreadable by legacy readers. </p>
</td></tr>
</table>

</div>
</div>
<a id="a447d53023355eb2e39e3e9a9a9b9d8dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a447d53023355eb2e39e3e9a9a9b9d8dc">&#9670;&nbsp;</a></span>CubeLayout</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenvtt.html#a447d53023355eb2e39e3e9a9a9b9d8dc">nvtt::CubeLayout</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies how to fold or unfold a cube map from or to a 2D texture. </p>
<dl class="section since"><dt>Since</dt><dd>NVTT 2.1 </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a447d53023355eb2e39e3e9a9a9b9d8dca707896e6ec737f4b3a763146d7b33702"></a>CubeLayout_VerticalCross&#160;</td><td class="fielddoc"><p>Unfolds into a 3*edgeLength (width) x 4*edgeLength texture, laid out as follows: ```text 2 140 3 5 ``` Face 5 is rotated 180 degrees. </p>
</td></tr>
<tr><td class="fieldname"><a id="a447d53023355eb2e39e3e9a9a9b9d8dca3fb7abb18cf90ada89e7285dc1f03422"></a>CubeLayout_HorizontalCross&#160;</td><td class="fielddoc"><p>Unfolds into a 4*edgeLength (width) x 3*edgeLength texture, laid out as follows: ```text 2 1405 3 ``` Face 5 is rotated 180 degrees. </p>
</td></tr>
<tr><td class="fieldname"><a id="a447d53023355eb2e39e3e9a9a9b9d8dca24b818d2b111932259f02aa69b52973a"></a>CubeLayout_Column&#160;</td><td class="fielddoc"><p>Writes each face in order into a column layout, like this: ```text 0 1 2 3 4 5 ``` </p>
</td></tr>
<tr><td class="fieldname"><a id="a447d53023355eb2e39e3e9a9a9b9d8dca24e62c1313b8ffe4c6ddc01aef5727df"></a>CubeLayout_Row&#160;</td><td class="fielddoc"><p>Writes each face in order into a row layout, like this: ```text 012345 ``` </p>
</td></tr>
<tr><td class="fieldname"><a id="a447d53023355eb2e39e3e9a9a9b9d8dcabf6eed2e38bb04ec6e660b136fede3da"></a>CubeLayout_LatitudeLongitude&#160;</td><td class="fielddoc"><p>Same as CubeLayout_VerticalCross. </p>
</td></tr>
</table>

</div>
</div>
<a id="acffe2adb946ca4eeae692ef547d57ca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acffe2adb946ca4eeae692ef547d57ca6">&#9670;&nbsp;</a></span>EdgeFixup</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenvtt.html#acffe2adb946ca4eeae692ef547d57ca6">nvtt::EdgeFixup</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use EdgeFixup_None if unsure; this affects how certain cube surface processing algorithms work. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="acffe2adb946ca4eeae692ef547d57ca6affcf62e8e27e7351dce5c92908419767"></a>EdgeFixup_None&#160;</td><td class="fielddoc"><p>No effect. </p>
</td></tr>
<tr><td class="fieldname"><a id="acffe2adb946ca4eeae692ef547d57ca6aeda3d9a01b5bcf73994c5ebcc52c62d5"></a>EdgeFixup_Stretch&#160;</td><td class="fielddoc"><p>Slightly stretches and shifts the coordinate systems cosinePowerFilter() and fastResample() use. </p>
</td></tr>
<tr><td class="fieldname"><a id="acffe2adb946ca4eeae692ef547d57ca6abbcabb8211cceed5c1074b98d8575e4b"></a>EdgeFixup_Warp&#160;</td><td class="fielddoc"><p>Applies a cubic warp to each face's coordinate system in cosinePowerFilter() and fastResample(), warping texels closer to edges more. </p>
</td></tr>
<tr><td class="fieldname"><a id="acffe2adb946ca4eeae692ef547d57ca6a424f99e9f5ca67b49765dec421c8c27f"></a>EdgeFixup_Average&#160;</td><td class="fielddoc"><p>Currently unimplemented. </p>
</td></tr>
</table>

</div>
</div>
<a id="a88aa620b06c95f24957941e3bf64519b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88aa620b06c95f24957941e3bf64519b">&#9670;&nbsp;</a></span>EncodeFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenvtt.html#a88aa620b06c95f24957941e3bf64519b">nvtt::EncodeFlags</a> : uint32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode flags for <a class="el" href="structnvtt_1_1_encode_settings.html">EncodeSettings</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a88aa620b06c95f24957941e3bf64519ba81edab19a33ab5c3de43b8fd16517dbb"></a>EncodeFlags_UseGPU&#160;</td><td class="fielddoc"><p>Compress on the GPU if CUDA is available, instead of the CPU. </p>
</td></tr>
<tr><td class="fieldname"><a id="a88aa620b06c95f24957941e3bf64519ba2488c64c79e82ba5d3f8ebc2ff22d1dc"></a>EncodeFlags_OutputToGPUMem&#160;</td><td class="fielddoc"><p>The <code>output</code> pointer is a CUDA device pointer (e.g. returned by <code>cudaMalloc()</code>), instead of a pointer to system memory (e.g. returned by <code>malloc()</code>). </p>
</td></tr>
<tr><td class="fieldname"><a id="a88aa620b06c95f24957941e3bf64519ba29d2523dd83ce311a5184da0b625ebcd"></a>EncodeFlags_Opaque&#160;</td><td class="fielddoc"><p>Specifies that all pixels have an alpha component equal to 1.0f. If set, this makes compression slightly faster. It's valid to leave it unset even if the image is opaque. </p>
</td></tr>
</table>

</div>
</div>
<a id="ad1b50bb1a5bd8c44ab56092b30b9cd36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1b50bb1a5bd8c44ab56092b30b9cd36">&#9670;&nbsp;</a></span>Error</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenvtt.html#ad1b50bb1a5bd8c44ab56092b30b9cd36">nvtt::Error</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error codes. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structnvtt_1_1_error_handler.html" title="Inheritable interface for handling errors.">nvtt::ErrorHandler</a> </dd>
<dd>
<a class="el" href="namespacenvtt.html#aa1ae97a643706ccf2940c94e3ca622fd" title="Return string for the given error code.">errorString()</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad1b50bb1a5bd8c44ab56092b30b9cd36a6a363ba70afc161ff85a7a52c3d92bbb"></a>Error_None&#160;</td><td class="fielddoc"><p>No error. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad1b50bb1a5bd8c44ab56092b30b9cd36aeb5d8ad9e386b13229cabf5ba1405475"></a>Error_Unknown&#160;</td><td class="fielddoc"><p>Alias used before NVTT 3.2 for Error_None. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad1b50bb1a5bd8c44ab56092b30b9cd36a7ae62389be2e2e29a7a1690b8721c105"></a>Error_InvalidInput&#160;</td><td class="fielddoc"><p>The input to the function was invalid (for instance, a negative size). </p>
</td></tr>
<tr><td class="fieldname"><a id="ad1b50bb1a5bd8c44ab56092b30b9cd36a0c76f5e3b3d2b2ab2dae1c3b7bd291e6"></a>Error_UnsupportedFeature&#160;</td><td class="fielddoc"><p>Unsupported feature. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad1b50bb1a5bd8c44ab56092b30b9cd36a61ea8e163d282921fbb20d9c6d165c6a"></a>Error_CudaError&#160;</td><td class="fielddoc"><p>CUDA reported an error during an operation. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad1b50bb1a5bd8c44ab56092b30b9cd36a050e9ac65add6839c261409762f63e60"></a>Error_FileOpen&#160;</td><td class="fielddoc"><p>I/O error attempting to open the given file. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad1b50bb1a5bd8c44ab56092b30b9cd36a272b79737f04552ad274898397e73f45"></a>Error_FileWrite&#160;</td><td class="fielddoc"><p>I/O error attempting to write to the given file. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad1b50bb1a5bd8c44ab56092b30b9cd36aab5dbcdd40172c02fce91bf18ac46f36"></a>Error_UnsupportedOutputFormat&#160;</td><td class="fielddoc"><p>The chosen container does not support the requested format (for instance, attempting to store BC7 data in a DDS file without the DX10 header.) </p>
</td></tr>
<tr><td class="fieldname"><a id="ad1b50bb1a5bd8c44ab56092b30b9cd36a543f509e1a5e4b9955640b587d0533e4"></a>Error_Messaging&#160;</td><td class="fielddoc"><p>Internal error while invoking the message callback. </p>
<dl class="section since"><dt>Since</dt><dd>NVTT 3.2 </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="ad1b50bb1a5bd8c44ab56092b30b9cd36aff7d46df90c539ac4e5b3e644e369dda"></a>Error_OutOfHostMemory&#160;</td><td class="fielddoc"><p>Out of host memory (allocating a CPU-side buffer failed). </p>
<dl class="section since"><dt>Since</dt><dd>NVTT 3.2 </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="ad1b50bb1a5bd8c44ab56092b30b9cd36adab9e4b4c47bbf76ceddb32a23c99361"></a>Error_OutOfDeviceMemory&#160;</td><td class="fielddoc"><p>Out of device memory (allocating a GPU-side buffer failed). </p>
<dl class="section since"><dt>Since</dt><dd>NVTT 3.2 </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="ad1b50bb1a5bd8c44ab56092b30b9cd36ac0464ea6704860307af9193e8f490d67"></a>Error_OutputWrite&#160;</td><td class="fielddoc"><p>OutputOptions::writeData() returned false. </p>
<dl class="section since"><dt>Since</dt><dd>NVTT 3.2 </dd></dl>
</td></tr>
</table>

</div>
</div>
<a id="a77ad50b0ef658f079f5ec637a287fd6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77ad50b0ef658f079f5ec637a287fd6d">&#9670;&nbsp;</a></span>Format</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6d">nvtt::Format</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported block-compression formats, including compressor variants. </p>
<p>That is:</p><ul>
<li>'DXT1' is a format, 'DXT1a' and 'DXT1n' are DXT1 compressors.</li>
<li>'DXT3' is a format, 'DXT3n' is a DXT3 compressor. </li>
</ul>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a77ad50b0ef658f079f5ec637a287fd6dad70b3a5abe17d4e6cc1a731e4bee76a6"></a>Format_RGB&#160;</td><td class="fielddoc"><p>Linear RGB format. </p>
</td></tr>
<tr><td class="fieldname"><a id="a77ad50b0ef658f079f5ec637a287fd6da1e4b5108b4c89f805f2efafd826b03d3"></a>Format_RGBA&#160;</td><td class="fielddoc"><p>Linear RGBA format. </p>
</td></tr>
<tr><td class="fieldname"><a id="a77ad50b0ef658f079f5ec637a287fd6da9ca8e3f8d05a0fae928ae309608ef722"></a>Format_DXT1&#160;</td><td class="fielddoc"><p>DX9 - DXT1 format. </p>
</td></tr>
<tr><td class="fieldname"><a id="a77ad50b0ef658f079f5ec637a287fd6dad074d39474c02c1d4171d2545e3968b1"></a>Format_DXT1a&#160;</td><td class="fielddoc"><p>DX9 - DXT1 with binary alpha. </p>
</td></tr>
<tr><td class="fieldname"><a id="a77ad50b0ef658f079f5ec637a287fd6dac40dd2ca7ea53576720b7c20e1704312"></a>Format_DXT3&#160;</td><td class="fielddoc"><p>DX9 - DXT3 format. </p>
</td></tr>
<tr><td class="fieldname"><a id="a77ad50b0ef658f079f5ec637a287fd6daa2bd0a4fcc15b2a692a6d8929a43e4d3"></a>Format_DXT5&#160;</td><td class="fielddoc"><p>DX9 - DXT5 format. </p>
</td></tr>
<tr><td class="fieldname"><a id="a77ad50b0ef658f079f5ec637a287fd6dae15335efd54def95c6df709b3f020999"></a>Format_DXT5n&#160;</td><td class="fielddoc"><p>DX9 - DXT5 normal format. Stores a normal (x, y, z) as (R, G, B, A) = (1, y, 0, x). </p>
</td></tr>
<tr><td class="fieldname"><a id="a77ad50b0ef658f079f5ec637a287fd6da7eb461737e0fc882a93255789c7cadec"></a>Format_BC1&#160;</td><td class="fielddoc"><p>DX10 - BC1 (DXT1) format. </p>
</td></tr>
<tr><td class="fieldname"><a id="a77ad50b0ef658f079f5ec637a287fd6dad251519ccb2dcda1bc41e7cd1b2e1c4c"></a>Format_BC1a&#160;</td><td class="fielddoc"><p>DX10 - BC1 (DXT1) format. </p>
</td></tr>
<tr><td class="fieldname"><a id="a77ad50b0ef658f079f5ec637a287fd6da0b504e386c28119b49c6064a64452d66"></a>Format_BC2&#160;</td><td class="fielddoc"><p>DX10 - BC2 (DXT3) format. </p>
</td></tr>
<tr><td class="fieldname"><a id="a77ad50b0ef658f079f5ec637a287fd6dac8ee0455899fe6fde42300df20aaf282"></a>Format_BC3&#160;</td><td class="fielddoc"><p>DX10 - BC3 (DXT5) format. </p>
</td></tr>
<tr><td class="fieldname"><a id="a77ad50b0ef658f079f5ec637a287fd6da841bbc25f933d81b4a43c851c5440c64"></a>Format_BC3n&#160;</td><td class="fielddoc"><p>DX10 - BC3 (DXT5) normal format for improved compression, storing a normal (x, y, z) as (1, y, 0, x). </p>
</td></tr>
<tr><td class="fieldname"><a id="a77ad50b0ef658f079f5ec637a287fd6dadc47f6b455d3533d5d3bc7abd231a2fb"></a>Format_BC4&#160;</td><td class="fielddoc"><p>DX10 - BC4U (ATI1) format (one channel, unsigned) </p>
</td></tr>
<tr><td class="fieldname"><a id="a77ad50b0ef658f079f5ec637a287fd6daf01d343dcafe84c2084a5a86344bf1db"></a>Format_BC4S&#160;</td><td class="fielddoc"><p>DX10 - BC4S format (one channel, signed) </p>
</td></tr>
<tr><td class="fieldname"><a id="a77ad50b0ef658f079f5ec637a287fd6dab368e55b0d5dbffa54861a62db699526"></a>Format_ATI2&#160;</td><td class="fielddoc"><p>DX10 - ATI2 format, similar to BC5U, channel order GR instead of RG. </p>
</td></tr>
<tr><td class="fieldname"><a id="a77ad50b0ef658f079f5ec637a287fd6da7e53438784904c341ff65d3ed8bac4af"></a>Format_BC5&#160;</td><td class="fielddoc"><p>DX10 - BC5U format (two channels, unsigned) </p>
</td></tr>
<tr><td class="fieldname"><a id="a77ad50b0ef658f079f5ec637a287fd6dade3eb3f3d00102653de87f48a4c53b45"></a>Format_BC5S&#160;</td><td class="fielddoc"><p>DX10 - BC5S format (two channels, signed) </p>
</td></tr>
<tr><td class="fieldname"><a id="a77ad50b0ef658f079f5ec637a287fd6dabf6dd404c065d8d9aa35266241771f80"></a>Format_DXT1n&#160;</td><td class="fielddoc"><p>Not supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="a77ad50b0ef658f079f5ec637a287fd6dafae7a3d4517b2e6bb9ffc3b30c35112d"></a>Format_CTX1&#160;</td><td class="fielddoc"><p>Not supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="a77ad50b0ef658f079f5ec637a287fd6da53a0a422d27f650216141a2b69419972"></a>Format_BC6U&#160;</td><td class="fielddoc"><p>DX10 - BC6 format (three-channel HDR, unsigned) </p>
</td></tr>
<tr><td class="fieldname"><a id="a77ad50b0ef658f079f5ec637a287fd6da57afee5146cfce8914252efe38ee69af"></a>Format_BC6S&#160;</td><td class="fielddoc"><p>DX10 - BC6 format (three-channel HDR, signed) </p>
</td></tr>
<tr><td class="fieldname"><a id="a77ad50b0ef658f079f5ec637a287fd6da7504a001d01a2e3f1cda648f1e32676b"></a>Format_BC7&#160;</td><td class="fielddoc"><p>DX10 - BC7 format (four channels, UNORM) </p>
</td></tr>
<tr><td class="fieldname"><a id="a77ad50b0ef658f079f5ec637a287fd6da3623a3b6e315c7cd908dd4ea78b68c58"></a>Format_BC3_RGBM&#160;</td><td class="fielddoc"><p>DX10 - BC3(DXT5) - using a magnitude encoding to approximate three-channel HDR data in four UNORM channels. The input should be in the range [0,1], and this should give more accurate values closer to 0. On most devices, consider using BC6 instead.</p>
<p>To decompress this format, decompress it like a standard BC3 texture, then compute <code>(R, G, B)</code> from <code>(r, g, b, m)</code> using <code>fromRGBM()</code> with <code>range = 1</code> and <code>threshold = 0.25</code>:</p>
<p><code>M = m * 0.75 + 0.25</code>;</p>
<p><code>(R, G, B) = (r, g, b) * M</code></p>
<p>The idea is that since BC3 uses separate compression for the RGB and alpha blocks, the RGB and M signals can be independent. Additionally, the compressor can account for the RGB compression error. This will print warnings if any of the computed m values were greater than 1.0. </p>
</td></tr>
<tr><td class="fieldname"><a id="a77ad50b0ef658f079f5ec637a287fd6dacd61083f3787f211cdc3e7d27acf0bcb"></a>Format_ASTC_LDR_4x4&#160;</td><td class="fielddoc"><p>ASTC - LDR - format, tile size 4x4. </p>
</td></tr>
<tr><td class="fieldname"><a id="a77ad50b0ef658f079f5ec637a287fd6daa462932902c3804af0974ea419728caa"></a>Format_ASTC_LDR_5x4&#160;</td><td class="fielddoc"><p>ASTC - LDR - format, tile size 5x4. </p>
</td></tr>
<tr><td class="fieldname"><a id="a77ad50b0ef658f079f5ec637a287fd6da69fa601cd97b38a974ad5a94a1f3f9a4"></a>Format_ASTC_LDR_5x5&#160;</td><td class="fielddoc"><p>ASTC - LDR - format, tile size 5x5. </p>
</td></tr>
<tr><td class="fieldname"><a id="a77ad50b0ef658f079f5ec637a287fd6dae16bc6c24bb5c12f5b1bdfcfda621e49"></a>Format_ASTC_LDR_6x5&#160;</td><td class="fielddoc"><p>ASTC - LDR - format, tile size 6x5. </p>
</td></tr>
<tr><td class="fieldname"><a id="a77ad50b0ef658f079f5ec637a287fd6da7eaa6f0a5231f4803526021a8706578c"></a>Format_ASTC_LDR_6x6&#160;</td><td class="fielddoc"><p>ASTC - LDR - format, tile size 6x6. </p>
</td></tr>
<tr><td class="fieldname"><a id="a77ad50b0ef658f079f5ec637a287fd6da3a68b29ecfa982cccc6767d6689f0a5a"></a>Format_ASTC_LDR_8x5&#160;</td><td class="fielddoc"><p>ASTC - LDR - format, tile size 8x5. </p>
</td></tr>
<tr><td class="fieldname"><a id="a77ad50b0ef658f079f5ec637a287fd6dab7f9c4ca1719ae5e4eceb3ce0a2f8901"></a>Format_ASTC_LDR_8x6&#160;</td><td class="fielddoc"><p>ASTC - LDR - format, tile size 8x6. </p>
</td></tr>
<tr><td class="fieldname"><a id="a77ad50b0ef658f079f5ec637a287fd6dae931d404efcdffa4b2dbabf9fdf54228"></a>Format_ASTC_LDR_8x8&#160;</td><td class="fielddoc"><p>ASTC - LDR - format, tile size 8x8. </p>
</td></tr>
<tr><td class="fieldname"><a id="a77ad50b0ef658f079f5ec637a287fd6da697ca508a97e9e064f7434863e39f41e"></a>Format_ASTC_LDR_10x5&#160;</td><td class="fielddoc"><p>ASTC - LDR - format, tile size 10x5. </p>
</td></tr>
<tr><td class="fieldname"><a id="a77ad50b0ef658f079f5ec637a287fd6da7625882a2047accb75e68e3c3aa10ccf"></a>Format_ASTC_LDR_10x6&#160;</td><td class="fielddoc"><p>ASTC - LDR - format, tile size 10x6. </p>
</td></tr>
<tr><td class="fieldname"><a id="a77ad50b0ef658f079f5ec637a287fd6da4c8c8b6ec09ff02cc4f3802b79ace3e0"></a>Format_ASTC_LDR_10x8&#160;</td><td class="fielddoc"><p>ASTC - LDR - format, tile size 10x8. </p>
</td></tr>
<tr><td class="fieldname"><a id="a77ad50b0ef658f079f5ec637a287fd6daf8842b25b9be7ace43116e155dcd18a6"></a>Format_ASTC_LDR_10x10&#160;</td><td class="fielddoc"><p>ASTC - LDR - format, tile size 10x10. </p>
</td></tr>
<tr><td class="fieldname"><a id="a77ad50b0ef658f079f5ec637a287fd6da8aae371759244af41fe3e77e7a904d10"></a>Format_ASTC_LDR_12x10&#160;</td><td class="fielddoc"><p>ASTC - LDR - format, tile size 12x10. </p>
</td></tr>
<tr><td class="fieldname"><a id="a77ad50b0ef658f079f5ec637a287fd6dac03f729d1aede99d35414fd9b524a41a"></a>Format_ASTC_LDR_12x12&#160;</td><td class="fielddoc"><p>ASTC - LDR - format, tile size 12x12. </p>
</td></tr>
<tr><td class="fieldname"><a id="a77ad50b0ef658f079f5ec637a287fd6dadc0b2bd1f884f91c596956d8631bb8c6"></a>Format_Unset&#160;</td><td class="fielddoc"><p>Placeholder in structs to produce errors if a format is not explicitly set, since format 0 is Format_RGB. </p>
</td></tr>
</table>

</div>
</div>
<a id="a7ea4cd82d5104d66e14f5524442c5f5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ea4cd82d5104d66e14f5524442c5f5e">&#9670;&nbsp;</a></span>InputFormat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenvtt.html#a7ea4cd82d5104d66e14f5524442c5f5e">nvtt::InputFormat</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Input formats. Used when creating an <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">nvtt::Surface</a> from an RGB/RGBA array. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7ea4cd82d5104d66e14f5524442c5f5eaf8b3af0719535e2e45599d0b20a463d2"></a>InputFormat_BGRA_8UB&#160;</td><td class="fielddoc"><p>[0, 255] 8 bit uint </p>
</td></tr>
<tr><td class="fieldname"><a id="a7ea4cd82d5104d66e14f5524442c5f5ea2fcc1076f7eb98eb300757660fa8de07"></a>InputFormat_BGRA_8SB&#160;</td><td class="fielddoc"><p>[-127, 127] 8 bit int </p>
</td></tr>
<tr><td class="fieldname"><a id="a7ea4cd82d5104d66e14f5524442c5f5ea351131926eee5bf0c0d0ed706699e2f0"></a>InputFormat_RGBA_16F&#160;</td><td class="fielddoc"><p>16 bit floating point. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7ea4cd82d5104d66e14f5524442c5f5ea5c06b40c2edcfb0c948ebdc003c55a17"></a>InputFormat_RGBA_32F&#160;</td><td class="fielddoc"><p>32 bit floating point. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7ea4cd82d5104d66e14f5524442c5f5ea7d8245786e1f39d2a9b8fb6baa2005c8"></a>InputFormat_R_32F&#160;</td><td class="fielddoc"><p>Single channel 32 bit floating point. </p>
</td></tr>
</table>

</div>
</div>
<a id="a28d4701da3f4e6935956949dab69c479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28d4701da3f4e6935956949dab69c479">&#9670;&nbsp;</a></span>MipmapFilter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenvtt.html#a28d4701da3f4e6935956949dab69c479">nvtt::MipmapFilter</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mipmap downsampling filters. Each of these can be customized using <code>filterWidth</code> and <code>params</code> when calling <a class="el" href="structnvtt_1_1_surface.html#ab85e9ae8132a60fcf923300687af2778" title="Resizes this surface to create the next mip in a mipmap chain.">Surface::buildNextMipmap()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a28d4701da3f4e6935956949dab69c479a5aed6ac6d80b602d7bd7d8fd2d977697"></a>MipmapFilter_Box&#160;</td><td class="fielddoc"><p>Box filter is quite good and very fast. It has some special paths for downsampling by exactly a factor of 2. <code>filterWidth</code> defaults to 0.5; <code>box(x)</code> is equal to 1 when <code>|x| &lt; filterWidth</code> and 0 otherwise. </p>
</td></tr>
<tr><td class="fieldname"><a id="a28d4701da3f4e6935956949dab69c479a484a5118a16886793c921a3f17c04a2c"></a>MipmapFilter_Triangle&#160;</td><td class="fielddoc"><p>Triangle filter blurs the results too much, but that might be what you want. <code>filterWidth</code> defaults to 1.0; <code>triangle(x)</code> is equal to <code>filterWidth - |x|</code> when <code>|x| &lt; filterWidth</code> and 0 otherwise. </p>
</td></tr>
<tr><td class="fieldname"><a id="a28d4701da3f4e6935956949dab69c479ae4a53887c8ee06fd999f022eefa29c5e"></a>MipmapFilter_Kaiser&#160;</td><td class="fielddoc"><p>Kaiser-windowed Sinc filter is the best downsampling filter, and close to a mathematically ideal windowing filter. If the window size is too large, it can introduce ringing.</p>
<p><code>filterWidth</code> controls the width of the Kaiser window. Larger values take longer to compute and include more oscillations of the sinc filter.</p>
<p><code>param[0]</code> (default: 4.0f) sets <code>alpha</code>, the sharpness of the Kaiser window. Higher values make the main lobe wider, but reduce sideband energy.</p>
<p><code>param[1]</code> (default: 1.0f) controls the frequency of the sinc filter. Higher values include higher frequencies.</p>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Kaiser_window">https://en.wikipedia.org/wiki/Kaiser_window</a> </dd></dl>
</td></tr>
</table>

</div>
</div>
<a id="a445e3b46e43013ef66771e98f7b1e0ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a445e3b46e43013ef66771e98f7b1e0ba">&#9670;&nbsp;</a></span>NormalTransform</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenvtt.html#a445e3b46e43013ef66771e98f7b1e0ba">nvtt::NormalTransform</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies a normal transformation, used to store 3D (x, y, z) normals in 2D (x, y). </p>
<p>We define these in terms of their 2D -&gt; 3D reconstructions, since their transformations are the inverse of the reconstructions. Most require z &gt;= 0.0f.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structnvtt_1_1_surface.html#aa9589b42199086cf7fcb4f99a0bd243d" title="Applies a 3D-&gt;2D normal transformation, setting the z (blue) channel to 0.">Surface::transformNormals()</a> </dd>
<dd>
<a class="el" href="structnvtt_1_1_surface.html#ad186ad17e1f204e00ecb54e018814cad" title="Reconstructs 3D normals from 2D transformed normals.">Surface::reconstructNormals()</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>NVTT 2.1 </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a445e3b46e43013ef66771e98f7b1e0baa7a435baa677e410f036ae06441229333"></a>NormalTransform_Orthographic&#160;</td><td class="fielddoc"><p>Reconstructs the z component using <code>z = sqrt(1 - x^2 + y^2)</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a445e3b46e43013ef66771e98f7b1e0baac7ed9d9e81f80b4e11e1f53ab4f6f0f9"></a>NormalTransform_Stereographic&#160;</td><td class="fielddoc"><p>Stereographic projection (like looking from the bottom of the sphere of normals and projecting points onto a plane at z = 1). Reconstructed using <code>d = 2/(1 + min(x^2 + y^2, 1)); return (x*d, y*d, d-1)</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a445e3b46e43013ef66771e98f7b1e0baa80b2a507b4e75a1febccfb2044cd86c8"></a>NormalTransform_Paraboloid&#160;</td><td class="fielddoc"><p>Reconstructed using <code>normalize(x, y, 1 - min(x^2 + y^2, 1))</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a445e3b46e43013ef66771e98f7b1e0baa99c18c7689a8117272ab957e3bd78a4a"></a>NormalTransform_Quartic&#160;</td><td class="fielddoc"><p>Reconstructed using <code>normalize(x, y, (1-x^2)(1-y^2))</code>. </p>
</td></tr>
</table>

</div>
</div>
<a id="accbc2d4c0396fc4e6d75d19e435c88ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accbc2d4c0396fc4e6d75d19e435c88ed">&#9670;&nbsp;</a></span>PixelType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenvtt.html#accbc2d4c0396fc4e6d75d19e435c88ed">nvtt::PixelType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pixel value types. </p>
<p>These are used for Format_RGB: they indicate how the output should be interpreted, but do not have any influence over the input. They are ignored for other compression modes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="accbc2d4c0396fc4e6d75d19e435c88eda36283fd855802ab127337a9204a1abac"></a>PixelType_UnsignedNorm&#160;</td><td class="fielddoc"><p>Used to indicate a DXGI_..._UNORM format. </p>
</td></tr>
<tr><td class="fieldname"><a id="accbc2d4c0396fc4e6d75d19e435c88edac5f45ced167de5441252bb48cedaae11"></a>PixelType_SignedNorm&#160;</td><td class="fielddoc"><p>Not supported yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="accbc2d4c0396fc4e6d75d19e435c88eda6f44a7d0693e3706916061221bc76724"></a>PixelType_UnsignedInt&#160;</td><td class="fielddoc"><p>Not supported yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="accbc2d4c0396fc4e6d75d19e435c88eda86f04728921c58b535e40d9b4e156123"></a>PixelType_SignedInt&#160;</td><td class="fielddoc"><p>Not supported yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="accbc2d4c0396fc4e6d75d19e435c88eda83f9ceb43bd9b001b835e39f08111db3"></a>PixelType_Float&#160;</td><td class="fielddoc"><p>Used to indicate a DXGI_..._FLOAT format. </p>
</td></tr>
<tr><td class="fieldname"><a id="accbc2d4c0396fc4e6d75d19e435c88edab8107297b020c703bc308794cbbdf6d5"></a>PixelType_UnsignedFloat&#160;</td><td class="fielddoc"><p>Used to indicate a DXGI_..._UF16 format. Unused. </p>
</td></tr>
<tr><td class="fieldname"><a id="accbc2d4c0396fc4e6d75d19e435c88edabb4c7c8a272083c0b14c7f8fdbf4f77b"></a>PixelType_SharedExp&#160;</td><td class="fielddoc"><p>Shared exponent. Only supported for DXGI_FORMAT_R9G9B9E5_SHAREDEXP. </p>
</td></tr>
</table>

</div>
</div>
<a id="a5a4632cb59f63e6af3fc88fdfe5e44ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a4632cb59f63e6af3fc88fdfe5e44ee">&#9670;&nbsp;</a></span>Quality</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenvtt.html#a5a4632cb59f63e6af3fc88fdfe5e44ee">nvtt::Quality</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Quality modes. </p>
<p>These can be used to trade off speed of compression for lower error, and often selects the specific compression algorithm that will be used. Here's a table showing which (format, quality) combinations support CUDA acceleration:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Quality   </th><th class="markdownTableHeadNone">BC1   </th><th class="markdownTableHeadNone">BC1a   </th><th class="markdownTableHeadNone">BC2   </th><th class="markdownTableHeadNone">BC3   </th><th class="markdownTableHeadNone">BC3n   </th><th class="markdownTableHeadNone">RGBM   </th><th class="markdownTableHeadNone">BC4   </th><th class="markdownTableHeadNone">BC5   </th><th class="markdownTableHeadNone">BC6   </th><th class="markdownTableHeadNone">BC7   </th><th class="markdownTableHeadNone">ASTC    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Fastest   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Normal   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Production   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">No (slow)   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Highest   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">No (slow)   </td><td class="markdownTableBodyNone">Yes   </td></tr>
</table>
<p>See the documentation of the different compression functions in <a class="el" href="nvtt__lowlevel_8h.html">nvtt_lowlevel.h</a> for more information. </p>

</div>
</div>
<a id="a3607100ce561fdaa3859abd0f05878c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3607100ce561fdaa3859abd0f05878c7">&#9670;&nbsp;</a></span>ResizeFilter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenvtt.html#a3607100ce561fdaa3859abd0f05878c7">nvtt::ResizeFilter</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Texture resizing filters. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3607100ce561fdaa3859abd0f05878c7ac608b4be1bb223cfd73e5aac2a002019"></a>ResizeFilter_Box&#160;</td><td class="fielddoc"><p>Box filter. Fast, but produces nearest-neighbor artifacts when upsampling. </p><dl class="section see"><dt>See also</dt><dd>nvtt::MipmapFilter::MipmapFilter_Box </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a3607100ce561fdaa3859abd0f05878c7a86e98691c89dc3a4cd0b24bb2fd173cd"></a>ResizeFilter_Triangle&#160;</td><td class="fielddoc"><p>Triangle (tent) filter. It can blur the results too much, but that might be what you want. </p><dl class="section see"><dt>See also</dt><dd>nvtt::MipmapFilter::MipmapFilter_Triangle </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a3607100ce561fdaa3859abd0f05878c7a6765919b82bb52e3384cd3b164347962"></a>ResizeFilter_Kaiser&#160;</td><td class="fielddoc"><p>Kaiser-windowed Sinc filter. </p><dl class="section see"><dt>See also</dt><dd>nvtt::MipmapFilter::MipmapFilter_Kaiser </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a3607100ce561fdaa3859abd0f05878c7ae014671bd84ab8296e2f1550f6afd7ee"></a>ResizeFilter_Mitchell&#160;</td><td class="fielddoc"><p>Mitchell &amp; Netravali's two parameter cubic filter.</p>
<p><code>filterWidth</code> (default: 2.0f) can truncate the filter, but should usually be left at the default.</p>
<p><code>param[0]</code> (default: 1/3) sets B.</p>
<p><code>param[1]</code> (default: 2/3) sets C.</p>
<dl class="section see"><dt>See also</dt><dd>"Reconstruction Filters in Computer Graphics", SIGGRAPH 1988</dd>
<dd>
<a href="https://en.wikipedia.org/wiki/Mitchell%E2%80%93Netravali_filters">https://en.wikipedia.org/wiki/Mitchell%E2%80%93Netravali_filters</a> </dd></dl>
</td></tr>
</table>

</div>
</div>
<a id="a673a22796ec42ae50e14ab1ed6906bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a673a22796ec42ae50e14ab1ed6906bd5">&#9670;&nbsp;</a></span>RoundMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenvtt.html#a673a22796ec42ae50e14ab1ed6906bd5">nvtt::RoundMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extents rounding mode. </p>
<p>Determines how to round sizes to different sets when shrinking an image.</p>
<p>For each of the PowerOfTwo modes, <code>maxExtent</code> is first rounded to the previous power of two.</p>
<p>Then all extents are scaled and truncated without changing the aspect ratio, using <code>s = max((s * maxExtent) / m, 1)</code>, where <code>m</code> is the maximum width, height, or depth.</p>
<p>If the texture is a cube map, the width and height are then averaged to make the resulting texture square.</p>
<p>Finally, extents are rounded to a set of possible sizes depending on this enum.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacenvtt.html#a73aebd76a0eef81407c40b5b93ee7c10" title="Geting the target extent for round-mode and texture-type. (New in NVTT 3.0)">getTargetExtent()</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a673a22796ec42ae50e14ab1ed6906bd5ae8a8417fa16eb6d657bec4a6a34a4eb5"></a>RoundMode_None&#160;</td><td class="fielddoc"><p>Each extent is left as-is. </p>
</td></tr>
<tr><td class="fieldname"><a id="a673a22796ec42ae50e14ab1ed6906bd5a6c20fa585fc05a9fa78907cb75fd192e"></a>RoundMode_ToNextPowerOfTwo&#160;</td><td class="fielddoc"><p>Each extent is rounded up to the next power of two. </p>
</td></tr>
<tr><td class="fieldname"><a id="a673a22796ec42ae50e14ab1ed6906bd5a62447741e676e7442edfa9a160f14be0"></a>RoundMode_ToNearestPowerOfTwo&#160;</td><td class="fielddoc"><p>Each extent is rounded either up or down to the nearest power of two. </p>
</td></tr>
<tr><td class="fieldname"><a id="a673a22796ec42ae50e14ab1ed6906bd5aa11b8ae64e7890e5037d6984b96d14a5"></a>RoundMode_ToPreviousPowerOfTwo&#160;</td><td class="fielddoc"><p>Each element is rounded down to the next power of two. </p>
</td></tr>
</table>

</div>
</div>
<a id="a4e52ab92a29b129b3b6c39c762940eae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e52ab92a29b129b3b6c39c762940eae">&#9670;&nbsp;</a></span>Severity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenvtt.html#a4e52ab92a29b129b3b6c39c762940eae">nvtt::Severity</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Message severity. </p>
<dl class="section since"><dt>Since</dt><dd>NVTT 3.2 </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4e52ab92a29b129b3b6c39c762940eaeaf30f258dc0a2d3cd025d126a673ed6f3"></a>Severity_Info&#160;</td><td class="fielddoc"><p>An informative message, such as statistics or current computation progress. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4e52ab92a29b129b3b6c39c762940eaea4c6473576ef788248f30255258261995"></a>Severity_Warning&#160;</td><td class="fielddoc"><p>A warning. For instance, an app may get a warning if it tries to enable CUDA acceleration, but no CUDA driver is available (which requires NVTT to use its CPU fallbacks). </p>
</td></tr>
<tr><td class="fieldname"><a id="a4e52ab92a29b129b3b6c39c762940eaea3727c52fc9062fd5292ef91ff85e3a46"></a>Severity_Error&#160;</td><td class="fielddoc"><p>An error. For instance, an API may have been called incorrectly, or CUDA may have run out of memory. The <code>Error</code> field of the message callback will be set to an appropriate value. </p>
</td></tr>
</table>

</div>
</div>
<a id="a30709ef62a9d666f2be7f34cce8e3b94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30709ef62a9d666f2be7f34cce8e3b94">&#9670;&nbsp;</a></span>ToneMapper</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenvtt.html#a30709ef62a9d666f2be7f34cce8e3b94">nvtt::ToneMapper</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tone mapping functions. </p>
<dl class="section since"><dt>Since</dt><dd>NVTT 2.1 </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a30709ef62a9d666f2be7f34cce8e3b94ae75755a83e2455024daa028f9997e142"></a>ToneMapper_Linear&#160;</td><td class="fielddoc"><p>Colors inside [0,1)^3 are preserved; colors outside are tone mapped using (r', g', b') = (r, g, b)/max(r, g, b). This clamps colors to the RGB cube, but preserves hue. It is not invertible. </p>
</td></tr>
<tr><td class="fieldname"><a id="a30709ef62a9d666f2be7f34cce8e3b94a4eac0b21fc9b9abaa609aaccbc8b692d"></a>ToneMapper_Reinhard&#160;</td><td class="fielddoc"><p>Applies a Reinhard operator to each channel: c' = c / (c + 1). </p>
</td></tr>
<tr><td class="fieldname"><a id="a30709ef62a9d666f2be7f34cce8e3b94ae212ae6b6b95ef74d99e8c294f0582a4"></a>ToneMapper_Reindhart&#160;</td><td class="fielddoc"><p>Name for backwards compatibility. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacenvtt.html#a30709ef62a9d666f2be7f34cce8e3b94a4eac0b21fc9b9abaa609aaccbc8b692d" title="Applies a Reinhard operator to each channel: c&#39; = c / (c + 1).">ToneMapper_Reinhard</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a30709ef62a9d666f2be7f34cce8e3b94a88b4b1bc1882ee68b7148e3e36fe155f"></a>ToneMapper_Halo&#160;</td><td class="fielddoc"><p>Applies an exponential tone mapper to each channel: c' = 1 - 2^(-c). </p>
</td></tr>
<tr><td class="fieldname"><a id="a30709ef62a9d666f2be7f34cce8e3b94ab9ee3d3f346369d1097532952c3f0baf"></a>ToneMapper_Lightmap&#160;</td><td class="fielddoc"><p>Same as <a class="el" href="namespacenvtt.html#a30709ef62a9d666f2be7f34cce8e3b94ae75755a83e2455024daa028f9997e142">ToneMapper_Linear</a>. </p>
</td></tr>
</table>

</div>
</div>
<a id="ae939a4f095a98e5176153b81dba28321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae939a4f095a98e5176153b81dba28321">&#9670;&nbsp;</a></span>ValueType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenvtt.html#ae939a4f095a98e5176153b81dba28321">nvtt::ValueType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Value type of the input images. The input buffer will use the same value type as the input images </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae939a4f095a98e5176153b81dba28321a2af64236612722b24eb2b58858257b4b"></a>UINT8&#160;</td><td class="fielddoc"><p>8-bit unsigned integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae939a4f095a98e5176153b81dba28321a138041050ea3405a6c150a8814446720"></a>SINT8&#160;</td><td class="fielddoc"><p>8-bit signed integer. Can be casted to float by dividing by 127, with the exception that both -128 and -127 represent -1.0f. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae939a4f095a98e5176153b81dba28321aeadcb5f215901bc412fe1f946c4f460a"></a>FLOAT32&#160;</td><td class="fielddoc"><p>IEEE 754 single-precision floating-point: 1 sign bit, 8 exponent bits, and 23 mantissa bits. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae939a4f095a98e5176153b81dba28321a69cb5de6a59e2c359b3aa9eae0d1ba86"></a>FLOAT16&#160;</td><td class="fielddoc"><p>IEEE 754 half-precision floating-point: 1 sign bit, 5 exponent bits, and 10 mantissa bits. </p>
</td></tr>
</table>

</div>
</div>
<a id="a04c40c16cdcde3c6c3f2e7081777a146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04c40c16cdcde3c6c3f2e7081777a146">&#9670;&nbsp;</a></span>WrapMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenvtt.html#a04c40c16cdcde3c6c3f2e7081777a146">nvtt::WrapMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrap modes. Specifies how to handle coordinates outside the typical image range. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a04c40c16cdcde3c6c3f2e7081777a146ad11969ec5e66b90e4c7c55a2aa2542f0"></a>WrapMode_Clamp&#160;</td><td class="fielddoc"><p>Coordinates are clamped, moving them to the closest coordinate inside the image. </p>
</td></tr>
<tr><td class="fieldname"><a id="a04c40c16cdcde3c6c3f2e7081777a146aa974b2999b7a9ca5a0cbf5ebf52ecea9"></a>WrapMode_Repeat&#160;</td><td class="fielddoc"><p>The image is treated as if it repeats on both axes, mod each dimension. For instance, for a 4x4 image, (5, -2) wraps to (1, 2). </p>
</td></tr>
<tr><td class="fieldname"><a id="a04c40c16cdcde3c6c3f2e7081777a146a550cb72f50d0b0571a2db0badfb44083"></a>WrapMode_Mirror&#160;</td><td class="fielddoc"><p>Coordinates are treated as if they reflect every time they pass through the center of an edge texel. For instance, for a 10x10 image, (8, 0), (10, 0), (26, 0), and (28, 0) all mirror to (8, 0). </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a14ef44c2a4c9551980d0e85635a47e2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14ef44c2a4c9551980d0e85635a47e2a">&#9670;&nbsp;</a></span>nvtt_encode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_encode_settings.html">EncodeSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Low-level interface for compressing to any of NVTT's formats from a <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html" title="Structure containing all the input images from host memory. The image data is reordered by tiles.">CPUInputBuffer</a>. If encoding succeeded, returns true. On failure, logs at least one error (</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacenvtt.html#a9b365e96db619c235d9b5e5907c78ac3">nvtt::setMessageCallback()</a>) and returns false.</dd></dl>
<p>Here's an example of how to encode data in CPU memory to BC7 format on the GPU, writing the output to CUDA device memory:</p>
<div class="fragment"><div class="line"><span class="comment">// Given void* d_outputData, a pointer to where the compressed data</span></div>
<div class="line"><span class="comment">// should be written on the GPU, and a CPUInputBuffer cpuInput:</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacenvtt.html">nvtt</a>;</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> settings = EncodeSettings().SetFormat(<a class="code" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6da7504a001d01a2e3f1cda648f1e32676b">Format_BC7</a>)</div>
<div class="line">                                      .SetOutputToGPUMem(<span class="keyword">true</span>);</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="namespacenvtt.html#a14ef44c2a4c9551980d0e85635a47e2a">nvtt_encode</a>(cpuInput, d_outputData, settings))</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Encoding succeeded! Do something with the data here.</span></div>
<div class="line">}</div>
<div class="ttc" id="anamespacenvtt_html"><div class="ttname"><a href="namespacenvtt.html">nvtt</a></div><div class="ttdoc">Namespace for all public non-macro NVTT fields.</div><div class="ttdef"><b>Definition:</b> nvtt.h:52</div></div>
<div class="ttc" id="anamespacenvtt_html_a14ef44c2a4c9551980d0e85635a47e2a"><div class="ttname"><a href="namespacenvtt.html#a14ef44c2a4c9551980d0e85635a47e2a">nvtt::nvtt_encode</a></div><div class="ttdeci">bool NVTT_API nvtt_encode(const CPUInputBuffer &amp;input, void *output, const EncodeSettings &amp;settings)</div></div>
<div class="ttc" id="anamespacenvtt_html_a77ad50b0ef658f079f5ec637a287fd6da7504a001d01a2e3f1cda648f1e32676b"><div class="ttname"><a href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6da7504a001d01a2e3f1cda648f1e32676b">nvtt::Format_BC7</a></div><div class="ttdeci">@ Format_BC7</div><div class="ttdoc">DX10 - BC7 format (four channels, UNORM)</div><div class="ttdef"><b>Definition:</b> nvtt_lowlevel.h:239</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in CPU memory.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output: CUDA device pointer if <code>settings.encode_flags</code> includes ENCODE_USE_GPU, and a pointer to CPU memory otherwise.</td></tr>
    <tr><td class="paramname">settings</td><td>Encoder settings, including the compression format and quality.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>NVTT 3.2 </dd></dl>

</div>
</div>
<a id="a91dfb6d2042c4d5bcb1bb664bd87a42f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91dfb6d2042c4d5bcb1bb664bd87a42f">&#9670;&nbsp;</a></span>nvtt_encode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_encode_settings.html">EncodeSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Low-level interface for compressing to any of NVTT's formats from a <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html" title="Structure containing all the input images from device memory. The image data is reordered by tiles.">GPUInputBuffer</a>. If encoding succeeded, returns true. On failure, logs at least one error (</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacenvtt.html#a9b365e96db619c235d9b5e5907c78ac3">nvtt::setMessageCallback()</a>) and returns false.</dd></dl>
<p>Here's an example of how to encode data in GPU memory to BC7 format on the GPU, writing the output to CUDA device memory:</p>
<div class="fragment"><div class="line"><span class="comment">// Given void* d_outputData, a pointer to where the compressed data</span></div>
<div class="line"><span class="comment">// should be written on the GPU, and a GPUInputBuffer gpuInput:</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacenvtt.html">nvtt</a>;</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> settings = EncodeSettings().SetFormat(<a class="code" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6da7504a001d01a2e3f1cda648f1e32676b">Format_BC7</a>)</div>
<div class="line">                                      .SetOutputToGPUMem(<span class="keyword">true</span>);</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="namespacenvtt.html#a14ef44c2a4c9551980d0e85635a47e2a">nvtt_encode</a>(gpuInput, d_outputData, settings))</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Encoding succeeded! Do something with the data here.</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in GPU memory.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output: CUDA device pointer if <code>settings.encode_flags</code> includes ENCODE_USE_GPU, and a pointer to CPU memory otherwise.</td></tr>
    <tr><td class="paramname">settings</td><td>Encoder settings, including the compression format and quality.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Clearing <code>settings</code> flag ENCODE_USE_GPU is ignored; data compressed using this function is currently always compressed on the GPU.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>NVTT 3.2 </dd></dl>

</div>
</div>
<a id="a3c5eb0a19f8d66f6c9f5cf33f335c32f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c5eb0a19f8d66f6c9f5cf33f335c32f">&#9670;&nbsp;</a></span>nvtt_encode_astc() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_astc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>qualityLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>imageHasAlpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useGpu</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_device_mem</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to ASTC format from <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html" title="Structure containing all the input images from host memory. The image data is reordered by tiles.">CPUInputBuffer</a>. This supports 4 quality levels on both the CPU and GPU.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in CPU memory.</td></tr>
    <tr><td class="paramname">qualityLevel</td><td>The quality level, 0, 1, 2, or 3. Higher quality levels produce less compression error, but take longer.</td></tr>
    <tr><td class="paramname">imageHasAlpha</td><td>Specifies that some pixels in the image have an alpha value less than 1.0f. If false, this makes compression slightly faster. It's still valid to set it to true even if the image is opaque.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output: CUDA device pointer if <code>to_device_mem</code> is true, and a pointer to CPU memory otherwise.</td></tr>
    <tr><td class="paramname">useGpu</td><td>Whether to run the compression algorithm on the GPU as opposed to the CPU. See note on <code>slow_mode</code>.</td></tr>
    <tr><td class="paramname">to_device_mem</td><td>Specifies that <code>output</code> is a CUDA device pointer, rather than a pointer to CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a25b2a51a1949426c7f860c52c7561b97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25b2a51a1949426c7f860c52c7561b97">&#9670;&nbsp;</a></span>nvtt_encode_astc() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_astc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>qualityLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>imageHasAlpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_device_mem</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to ASTC format from <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html" title="Structure containing all the input images from device memory. The image data is reordered by tiles.">GPUInputBuffer</a>, always using GPU compression. This supports 4 quality levels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in GPU memory.</td></tr>
    <tr><td class="paramname">qualityLevel</td><td>The quality level, 0, 1, 2, or 3. Higher quality levels produce less compression error, but take longer.</td></tr>
    <tr><td class="paramname">imageHasAlpha</td><td>Specifies that some pixels in the image have an alpha value less than 1.0f. If false, this makes compression slightly faster. It's still valid to set it to true even if the image is opaque.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output: CUDA device pointer if <code>to_device_mem</code> is true, and a pointer to CPU memory otherwise.</td></tr>
    <tr><td class="paramname">to_device_mem</td><td>Specifies that <code>output</code> is a CUDA device pointer, rather than a pointer to CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f678e13767228c68dfcad1da61e8b7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f678e13767228c68dfcad1da61e8b7d">&#9670;&nbsp;</a></span>nvtt_encode_ati2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_ati2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>slow_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useGpu</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_device_mem</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to ATI2 format from <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html" title="Structure containing all the input images from host memory. The image data is reordered by tiles.">CPUInputBuffer</a>. No slow-mode algorithm for the GPU is available, so when <code>slow_mode</code> is true this ignores <code>useGPU</code> and compresses on the CPU.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in CPU memory.</td></tr>
    <tr><td class="paramname">slow_mode</td><td>If true, uses a slower but higher-quality compressor; otherwise, uses a faster but lower-quality compressor. Also overrides <code>useGPU</code> if true and uses the CPU for slow-mode compression.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output: CUDA device pointer if <code>to_device_mem</code> is true, and a pointer to CPU memory otherwise.</td></tr>
    <tr><td class="paramname">useGpu</td><td>Whether to run the compression algorithm on the GPU as opposed to the CPU. See note on <code>slow_mode</code>.</td></tr>
    <tr><td class="paramname">to_device_mem</td><td>Specifies that <code>output</code> is a CUDA device pointer, rather than a pointer to CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a393f3f5de7cdefa79e31b095384b6e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a393f3f5de7cdefa79e31b095384b6e14">&#9670;&nbsp;</a></span>nvtt_encode_ati2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_ati2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_device_mem</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to ATI2 format from <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html" title="Structure containing all the input images from device memory. The image data is reordered by tiles.">GPUInputBuffer</a>, always using GPU compression. This method has only one quality level, corresponding to CPU fast-mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in GPU memory.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output: CUDA device pointer if <code>to_device_mem</code> is true, and a pointer to CPU memory otherwise.</td></tr>
    <tr><td class="paramname">to_device_mem</td><td>Specifies that <code>output</code> is a CUDA device pointer, rather than a pointer to CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05bd68f7ce315c0c26124793512bc6ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05bd68f7ce315c0c26124793512bc6ed">&#9670;&nbsp;</a></span>nvtt_encode_bc1() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_bc1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fast_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useGpu</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_device_mem</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>NVTT 3's initial implementation of the low-level compression API below used a different function for each combination of the encoding format category and the input type. Because these functions have different signatures, we recommend using NVTT 3.2's nvtt_encode API above. The functions below are provided for backwards compatibility and will remain supported for all versions of NVTT 3. Interface for compressing to BC1 format from <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html" title="Structure containing all the input images from host memory. The image data is reordered by tiles.">CPUInputBuffer</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in CPU memory.</td></tr>
    <tr><td class="paramname">fast_mode</td><td>If true, uses a faster but lower-quality compressor; otherwise, uses a slower but higher-quality compressor. This applies to both CPU and GPU compression.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output: CUDA device pointer if <code>to_device_mem</code> is true, and a pointer to CPU memory otherwise.</td></tr>
    <tr><td class="paramname">useGpu</td><td>Whether to run the compression algorithm on the GPU as opposed to the CPU.</td></tr>
    <tr><td class="paramname">to_device_mem</td><td>Specifies that <code>output</code> is a CUDA device pointer, rather than a pointer to CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9e0e41149b87bd6c5d3f327ac7a0a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9e0e41149b87bd6c5d3f327ac7a0a97">&#9670;&nbsp;</a></span>nvtt_encode_bc1() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_bc1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fast_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_device_mem</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to BC1 format from <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html" title="Structure containing all the input images from device memory. The image data is reordered by tiles.">GPUInputBuffer</a>, always using GPU compression.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in GPU memory.</td></tr>
    <tr><td class="paramname">fast_mode</td><td>If true, uses a faster but lower-quality compressor; otherwise, uses a slower but higher-quality compressor. Compression always happens on the GPU, so CUDA must be available.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output: CUDA device pointer if <code>to_device_mem</code> is true, and a pointer to CPU memory otherwise.</td></tr>
    <tr><td class="paramname">to_device_mem</td><td>Specifies that <code>output</code> is a CUDA device pointer, rather than a pointer to CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5bd3ed1c285fc5e6c146cc9de88937bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bd3ed1c285fc5e6c146cc9de88937bb">&#9670;&nbsp;</a></span>nvtt_encode_bc1a() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_bc1a </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fast_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useGpu</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_device_mem</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to BC1a format from <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html" title="Structure containing all the input images from host memory. The image data is reordered by tiles.">CPUInputBuffer</a>. No fast-mode algorithm for the GPU is available, so when <code>fast_mode</code> is true this ignores <code>useGPU</code> and compresses on the CPU. In this case, slow-mode GPU compression may be faster than fast-mode CPU compression.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in CPU memory.</td></tr>
    <tr><td class="paramname">fast_mode</td><td>If true, uses a faster but lower-quality compressor; otherwise, uses a slower but higher-quality compressor. Also overrides <code>useGPU</code> if true and uses the CPU for fast-mode compression.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output: CUDA device pointer if <code>to_device_mem</code> is true, and a pointer to CPU memory otherwise.</td></tr>
    <tr><td class="paramname">useGpu</td><td>Whether to run the compression algorithm on the GPU as opposed to the CPU. See note on <code>fast_mode</code>.</td></tr>
    <tr><td class="paramname">to_device_mem</td><td>Specifies that <code>output</code> is a CUDA device pointer, rather than a pointer to CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61eefb6c30a92e72d297f3bf2fe39f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61eefb6c30a92e72d297f3bf2fe39f10">&#9670;&nbsp;</a></span>nvtt_encode_bc1a() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_bc1a </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_device_mem</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to BC1a format from <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html" title="Structure containing all the input images from device memory. The image data is reordered by tiles.">GPUInputBuffer</a>, always using GPU compression. This method has only one quality level, corresponding to CPU slow-mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in GPU memory.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output: CUDA device pointer if <code>to_device_mem</code> is true, and a pointer to CPU memory otherwise.</td></tr>
    <tr><td class="paramname">to_device_mem</td><td>Specifies that <code>output</code> is a CUDA device pointer, rather than a pointer to CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb08b8c7f7030e7473187ff5e986294f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb08b8c7f7030e7473187ff5e986294f">&#9670;&nbsp;</a></span>nvtt_encode_bc2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_bc2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fast_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useGpu</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_device_mem</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to BC2 format from <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html" title="Structure containing all the input images from host memory. The image data is reordered by tiles.">CPUInputBuffer</a>. No fast-mode algorithm for the GPU is available, so when <code>fast_mode</code> is true this ignores <code>useGPU</code> and compresses on the CPU. In this case, slow-mode GPU compression may be faster than fast-mode CPU compression.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in CPU memory.</td></tr>
    <tr><td class="paramname">fast_mode</td><td>If true, uses a faster but lower-quality compressor; otherwise, uses a slower but higher-quality compressor. Also overrides <code>useGPU</code> if true and uses the CPU for fast-mode compression.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output: CUDA device pointer if <code>to_device_mem</code> is true, and a pointer to CPU memory otherwise.</td></tr>
    <tr><td class="paramname">useGpu</td><td>Whether to run the compression algorithm on the GPU as opposed to the CPU. See note on <code>fast_mode</code>.</td></tr>
    <tr><td class="paramname">to_device_mem</td><td>Specifies that <code>output</code> is a CUDA device pointer, rather than a pointer to CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ae6bd44be0539af54582d5dd5aa88a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae6bd44be0539af54582d5dd5aa88a1">&#9670;&nbsp;</a></span>nvtt_encode_bc2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_bc2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_device_mem</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to BC2 format from <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html" title="Structure containing all the input images from device memory. The image data is reordered by tiles.">GPUInputBuffer</a>, always using GPU compression. This method has only one quality level, corresponding to CPU slow-mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in GPU memory.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output: CUDA device pointer if <code>to_device_mem</code> is true, and a pointer to CPU memory otherwise.</td></tr>
    <tr><td class="paramname">to_device_mem</td><td>Specifies that <code>output</code> is a CUDA device pointer, rather than a pointer to CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac335a276d5f79af2a762d76988e661ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac335a276d5f79af2a762d76988e661ad">&#9670;&nbsp;</a></span>nvtt_encode_bc3() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_bc3 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fast_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useGpu</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_device_mem</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to BC3 format from <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html" title="Structure containing all the input images from host memory. The image data is reordered by tiles.">CPUInputBuffer</a>. No fast-mode algorithm for the GPU is available, so when <code>fast_mode</code> is true this ignores <code>useGPU</code> and compresses on the CPU. In this case, slow-mode GPU compression may be faster than fast-mode CPU compression.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in CPU memory.</td></tr>
    <tr><td class="paramname">fast_mode</td><td>If true, uses a faster but lower-quality compressor; otherwise, uses a slower but higher-quality compressor. Also overrides <code>useGPU</code> if true and uses the CPU for fast-mode compression.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output: CUDA device pointer if <code>to_device_mem</code> is true, and a pointer to CPU memory otherwise.</td></tr>
    <tr><td class="paramname">useGpu</td><td>Whether to run the compression algorithm on the GPU as opposed to the CPU. See note on <code>fast_mode</code>.</td></tr>
    <tr><td class="paramname">to_device_mem</td><td>Specifies that <code>output</code> is a CUDA device pointer, rather than a pointer to CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaad95872eab2e29b5b4a7721c4a2b961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad95872eab2e29b5b4a7721c4a2b961">&#9670;&nbsp;</a></span>nvtt_encode_bc3() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_bc3 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_device_mem</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to BC3 format from <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html" title="Structure containing all the input images from device memory. The image data is reordered by tiles.">GPUInputBuffer</a>, always using GPU compression. This method has only one quality level, corresponding to CPU slow-mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in GPU memory.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output: CUDA device pointer if <code>to_device_mem</code> is true, and a pointer to CPU memory otherwise.</td></tr>
    <tr><td class="paramname">to_device_mem</td><td>Specifies that <code>output</code> is a CUDA device pointer, rather than a pointer to CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad69901604f7f6e6e1acb0486ad5db001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad69901604f7f6e6e1acb0486ad5db001">&#9670;&nbsp;</a></span>nvtt_encode_bc3_rgbm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_bc3_rgbm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to BC3 - rgbm format from <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html" title="Structure containing all the input images from host memory. The image data is reordered by tiles.">CPUInputBuffer</a>. This method is currently CPU-only and has 1 quality level. See <a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6da3623a3b6e315c7cd908dd4ea78b68c58">nvtt::Format_BC3_RGBM</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in CPU memory.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output in CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab82056d5ee5c0f852135d8cd6bab149e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab82056d5ee5c0f852135d8cd6bab149e">&#9670;&nbsp;</a></span>nvtt_encode_bc3n()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_bc3n </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>qualityLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to BC3n format from <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html" title="Structure containing all the input images from host memory. The image data is reordered by tiles.">CPUInputBuffer</a>. This method is currently CPU-only, but supports 3 quality levels</p><ul>
<li>0, 1, and 2. See <a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6da841bbc25f933d81b4a43c851c5440c64" title="DX10 - BC3 (DXT5) normal format for improved compression, storing a normal (x, y, z) as (1,...">nvtt::Format_BC3n</a>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in CPU memory.</td></tr>
    <tr><td class="paramname">qualityLevel</td><td>Higher quality levels produce less compression error, but take longer to compress. Can be 0, 1, or 2.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output in CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c370ed199a91ca69c4c01c9f6daed39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c370ed199a91ca69c4c01c9f6daed39">&#9670;&nbsp;</a></span>nvtt_encode_bc4() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_bc4 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>slow_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useGpu</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_device_mem</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to BC4U format from <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html" title="Structure containing all the input images from host memory. The image data is reordered by tiles.">CPUInputBuffer</a>. No slow-mode algorithm for the GPU is available, so when <code>slow_mode</code> is true this ignores <code>useGPU</code> and compresses on the CPU.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in CPU memory.</td></tr>
    <tr><td class="paramname">slow_mode</td><td>If true, uses a slower but higher-quality compressor; otherwise, uses a faster but lower-quality compressor. Also overrides <code>useGPU</code> if true and uses the CPU for slow-mode compression.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output: CUDA device pointer if <code>to_device_mem</code> is true, and a pointer to CPU memory otherwise.</td></tr>
    <tr><td class="paramname">useGpu</td><td>Whether to run the compression algorithm on the GPU as opposed to the CPU. See note on <code>slow_mode</code>.</td></tr>
    <tr><td class="paramname">to_device_mem</td><td>Specifies that <code>output</code> is a CUDA device pointer, rather than a pointer to CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa76314c0b925a24e3f509e4a212668ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa76314c0b925a24e3f509e4a212668ae">&#9670;&nbsp;</a></span>nvtt_encode_bc4() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_bc4 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_device_mem</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to BC4U format from <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html" title="Structure containing all the input images from device memory. The image data is reordered by tiles.">GPUInputBuffer</a>, always using GPU compression. This method has only one quality level, corresponding to CPU fast-mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in GPU memory.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output: CUDA device pointer if <code>to_device_mem</code> is true, and a pointer to CPU memory otherwise.</td></tr>
    <tr><td class="paramname">to_device_mem</td><td>Specifies that <code>output</code> is a CUDA device pointer, rather than a pointer to CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab15a4c506eb1c3b5ad89249ef3e8e340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab15a4c506eb1c3b5ad89249ef3e8e340">&#9670;&nbsp;</a></span>nvtt_encode_bc4s() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_bc4s </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>slow_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useGpu</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_device_mem</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to BC4S format from <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html" title="Structure containing all the input images from host memory. The image data is reordered by tiles.">CPUInputBuffer</a>. No slow-mode algorithm for the GPU is available, so when <code>slow_mode</code> is true this ignores <code>useGPU</code> and compresses on the CPU.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in CPU memory.</td></tr>
    <tr><td class="paramname">slow_mode</td><td>If true, uses a slower but higher-quality compressor; otherwise, uses a faster but lower-quality compressor. Also overrides <code>useGPU</code> if true and uses the CPU for slow-mode compression.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output: CUDA device pointer if <code>to_device_mem</code> is true, and a pointer to CPU memory otherwise.</td></tr>
    <tr><td class="paramname">useGpu</td><td>Whether to run the compression algorithm on the GPU as opposed to the CPU. See note on <code>slow_mode</code>.</td></tr>
    <tr><td class="paramname">to_device_mem</td><td>Specifies that <code>output</code> is a CUDA device pointer, rather than a pointer to CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3e7a48139329817c6b6acc3ae875c03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e7a48139329817c6b6acc3ae875c03">&#9670;&nbsp;</a></span>nvtt_encode_bc4s() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_bc4s </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_device_mem</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to BC4S format from <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html" title="Structure containing all the input images from device memory. The image data is reordered by tiles.">GPUInputBuffer</a>, always using GPU compression. This method has only one quality level, corresponding to CPU fast-mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in GPU memory.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output: CUDA device pointer if <code>to_device_mem</code> is true, and a pointer to CPU memory otherwise.</td></tr>
    <tr><td class="paramname">to_device_mem</td><td>Specifies that <code>output</code> is a CUDA device pointer, rather than a pointer to CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c96f1d819b4c61b42d537c102080c32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c96f1d819b4c61b42d537c102080c32">&#9670;&nbsp;</a></span>nvtt_encode_bc5() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_bc5 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>slow_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useGpu</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_device_mem</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to BC5U format from <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html" title="Structure containing all the input images from host memory. The image data is reordered by tiles.">CPUInputBuffer</a>. No slow-mode algorithm for the GPU is available, so when <code>slow_mode</code> is true this ignores <code>useGPU</code> and compresses on the CPU.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in CPU memory.</td></tr>
    <tr><td class="paramname">slow_mode</td><td>If true, uses a slower but higher-quality compressor; otherwise, uses a faster but lower-quality compressor. Also overrides <code>useGPU</code> if true and uses the CPU for slow-mode compression.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output: CUDA device pointer if <code>to_device_mem</code> is true, and a pointer to CPU memory otherwise.</td></tr>
    <tr><td class="paramname">useGpu</td><td>Whether to run the compression algorithm on the GPU as opposed to the CPU. See note on <code>slow_mode</code>.</td></tr>
    <tr><td class="paramname">to_device_mem</td><td>Specifies that <code>output</code> is a CUDA device pointer, rather than a pointer to CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3dfc0444515b1304ab9a1cb6eb9ff5b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dfc0444515b1304ab9a1cb6eb9ff5b8">&#9670;&nbsp;</a></span>nvtt_encode_bc5() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_bc5 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_device_mem</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to BC5U format from <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html" title="Structure containing all the input images from device memory. The image data is reordered by tiles.">GPUInputBuffer</a>, always using GPU compression. This method has only one quality level, corresponding to CPU fast-mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in GPU memory.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output: CUDA device pointer if <code>to_device_mem</code> is true, and a pointer to CPU memory otherwise.</td></tr>
    <tr><td class="paramname">to_device_mem</td><td>Specifies that <code>output</code> is a CUDA device pointer, rather than a pointer to CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e4d632aa6c550b8b461f4343125fe77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e4d632aa6c550b8b461f4343125fe77">&#9670;&nbsp;</a></span>nvtt_encode_bc5s() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_bc5s </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>slow_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useGpu</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_device_mem</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to BC5S format from <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html" title="Structure containing all the input images from host memory. The image data is reordered by tiles.">CPUInputBuffer</a>. No slow-mode algorithm for the GPU is available, so when <code>slow_mode</code> is true this ignores <code>useGPU</code> and compresses on the CPU.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in CPU memory.</td></tr>
    <tr><td class="paramname">slow_mode</td><td>If true, uses a slower but higher-quality compressor; otherwise, uses a faster but lower-quality compressor. Also overrides <code>useGPU</code> if true and uses the CPU for slow-mode compression.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output: CUDA device pointer if <code>to_device_mem</code> is true, and a pointer to CPU memory otherwise.</td></tr>
    <tr><td class="paramname">useGpu</td><td>Whether to run the compression algorithm on the GPU as opposed to the CPU. See note on <code>slow_mode</code>.</td></tr>
    <tr><td class="paramname">to_device_mem</td><td>Specifies that <code>output</code> is a CUDA device pointer, rather than a pointer to CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3ea7d013fca07b16f48745ad67b1e21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3ea7d013fca07b16f48745ad67b1e21">&#9670;&nbsp;</a></span>nvtt_encode_bc5s() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_bc5s </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_device_mem</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to BC5S format from <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html" title="Structure containing all the input images from device memory. The image data is reordered by tiles.">GPUInputBuffer</a>, always using GPU compression. This method has only one quality level, corresponding to CPU fast-mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in GPU memory.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output: CUDA device pointer if <code>to_device_mem</code> is true, and a pointer to CPU memory otherwise.</td></tr>
    <tr><td class="paramname">to_device_mem</td><td>Specifies that <code>output</code> is a CUDA device pointer, rather than a pointer to CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aebd712c6a68534c161e2e20fa3967663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebd712c6a68534c161e2e20fa3967663">&#9670;&nbsp;</a></span>nvtt_encode_bc6h() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_bc6h </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>slow_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_signed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useGpu</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_device_mem</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to BC6H format from <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html" title="Structure containing all the input images from host memory. The image data is reordered by tiles.">CPUInputBuffer</a>. No slow-mode algorithm for the GPU is available, so when <code>slow_mode</code> is true this ignores <code>useGPU</code> and compresses on the CPU.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in CPU memory.</td></tr>
    <tr><td class="paramname">slow_mode</td><td>If true, uses a slower but higher-quality compressor; otherwise, uses a faster but lower-quality compressor. Also overrides <code>useGPU</code> if true and uses the CPU for slow-mode compression.</td></tr>
    <tr><td class="paramname">is_signed</td><td>If true, compresses to the BC6S format, instead of BC6U.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output: CUDA device pointer if <code>to_device_mem</code> is true, and a pointer to CPU memory otherwise.</td></tr>
    <tr><td class="paramname">useGpu</td><td>Whether to run the compression algorithm on the GPU as opposed to the CPU. See note on <code>slow_mode</code>.</td></tr>
    <tr><td class="paramname">to_device_mem</td><td>Specifies that <code>output</code> is a CUDA device pointer, rather than a pointer to CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74857405343d8148e3aa8a840f5d9c1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74857405343d8148e3aa8a840f5d9c1e">&#9670;&nbsp;</a></span>nvtt_encode_bc6h() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_bc6h </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_signed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_device_mem</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to BC6H format from <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html" title="Structure containing all the input images from device memory. The image data is reordered by tiles.">GPUInputBuffer</a>, always using GPU compression. This method has only one quality level, corresponding to CPU fast-mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in GPU memory.</td></tr>
    <tr><td class="paramname">is_signed</td><td>If true, compresses to the BC6S format, instead of BC6U.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output: CUDA device pointer if <code>to_device_mem</code> is true, and a pointer to CPU memory otherwise.</td></tr>
    <tr><td class="paramname">to_device_mem</td><td>Specifies that <code>output</code> is a CUDA device pointer, rather than a pointer to CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc828476883ed40499d01622d2a0873f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc828476883ed40499d01622d2a0873f">&#9670;&nbsp;</a></span>nvtt_encode_bc7() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_bc7 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>slow_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>imageHasAlpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useGpu</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_device_mem</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to BC7 format from <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html" title="Structure containing all the input images from host memory. The image data is reordered by tiles.">CPUInputBuffer</a>. No slow-mode algorithm for the GPU is available, so when <code>slow_mode</code> is true this ignores <code>useGPU</code> and compresses on the CPU. The slow-mode CPU compressor is particularly slow in this case (as it searches though a very large space of possibilities), so fast-mode compression is recommended.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in CPU memory.</td></tr>
    <tr><td class="paramname">slow_mode</td><td>If true, uses a slower but higher-quality compressor; otherwise, uses a faster but lower-quality compressor. Also overrides <code>useGPU</code> if true and uses the CPU for slow-mode compression.</td></tr>
    <tr><td class="paramname">imageHasAlpha</td><td>Specifies that some pixels in the image have an alpha value less than 1.0f. If false, this makes compression slightly faster. It's still valid to set it to true even if the image is opaque.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output: CUDA device pointer if <code>to_device_mem</code> is true, and a pointer to CPU memory otherwise.</td></tr>
    <tr><td class="paramname">useGpu</td><td>Whether to run the compression algorithm on the GPU as opposed to the CPU. See note on <code>slow_mode</code>.</td></tr>
    <tr><td class="paramname">to_device_mem</td><td>Specifies that <code>output</code> is a CUDA device pointer, rather than a pointer to CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a80dbdb09bbe3f2702bad846d90b69578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80dbdb09bbe3f2702bad846d90b69578">&#9670;&nbsp;</a></span>nvtt_encode_bc7() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_bc7 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>imageHasAlpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_device_mem</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to BC7 format from <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html" title="Structure containing all the input images from device memory. The image data is reordered by tiles.">GPUInputBuffer</a>, always using GPU compression. This method has only one quality level, corresponding to CPU fast-mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in GPU memory.</td></tr>
    <tr><td class="paramname">imageHasAlpha</td><td>Specifies that some pixels in the image have an alpha value less than 1.0f. If false, this makes compression slightly faster. It's still valid to set it to true even if the image is opaque.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output: CUDA device pointer if <code>to_device_mem</code> is true, and a pointer to CPU memory otherwise.</td></tr>
    <tr><td class="paramname">to_device_mem</td><td>Specifies that <code>output</code> is a CUDA device pointer, rather than a pointer to CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b365e96db619c235d9b5e5907c78ac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b365e96db619c235d9b5e5907c78ac3">&#9670;&nbsp;</a></span>setMessageCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool nvtt::setMessageCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenvtt.html#a33b8617801c04cfe11ea9502eabdd892">MessageCallback</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>userData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the current thread's NVTT <code>MessageCallback</code>. NVTT calls this function whenever it encounters an error or performance warning, or has useful information. Here's an example showing how to use a message callback to detect and print errors: </p><div class="fragment"><div class="line">thread_local <span class="keywordtype">bool</span> caughtError = <span class="keyword">false</span>;</div>
<div class="line"><span class="keywordtype">void</span> customCallback(<a class="code" href="namespacenvtt.html#a4e52ab92a29b129b3b6c39c762940eae">nvtt::Severity</a> severity, <a class="code" href="namespacenvtt.html#ad1b50bb1a5bd8c44ab56092b30b9cd36">nvtt::Error</a> error,</div>
<div class="line">                    <span class="keyword">const</span> <span class="keywordtype">char</span>* message, <span class="keyword">const</span> <span class="keywordtype">void</span>* userData)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (severity == <a class="code" href="namespacenvtt.html#a4e52ab92a29b129b3b6c39c762940eaea3727c52fc9062fd5292ef91ff85e3a46">nvtt::Severity_Error</a>)</div>
<div class="line">    {</div>
<div class="line">        printf(<span class="stringliteral">&quot;ERROR: %s\n&quot;</span>, message);</div>
<div class="line">        caughtError = <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Example processing function; returns true on success</span></div>
<div class="line"><span class="keywordtype">bool</span> exampleProcessing(...)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="namespacenvtt.html#a9b365e96db619c235d9b5e5907c78ac3">nvtt::setMessageCallback</a>(customCallback, <span class="keyword">nullptr</span>);</div>
<div class="line">    GPUInputBuffer input(...);</div>
<div class="line">    <a class="code" href="namespacenvtt.html#adc828476883ed40499d01622d2a0873f">nvtt_encode_bc7</a>(input, ...);</div>
<div class="line">    <span class="keywordflow">return</span> !caughtError;</div>
<div class="line">}</div>
<div class="ttc" id="anamespacenvtt_html_a4e52ab92a29b129b3b6c39c762940eae"><div class="ttname"><a href="namespacenvtt.html#a4e52ab92a29b129b3b6c39c762940eae">nvtt::Severity</a></div><div class="ttdeci">Severity</div><div class="ttdoc">Message severity.</div><div class="ttdef"><b>Definition:</b> nvtt.h:325</div></div>
<div class="ttc" id="anamespacenvtt_html_a4e52ab92a29b129b3b6c39c762940eaea3727c52fc9062fd5292ef91ff85e3a46"><div class="ttname"><a href="namespacenvtt.html#a4e52ab92a29b129b3b6c39c762940eaea3727c52fc9062fd5292ef91ff85e3a46">nvtt::Severity_Error</a></div><div class="ttdeci">@ Severity_Error</div><div class="ttdef"><b>Definition:</b> nvtt.h:336</div></div>
<div class="ttc" id="anamespacenvtt_html_a9b365e96db619c235d9b5e5907c78ac3"><div class="ttname"><a href="namespacenvtt.html#a9b365e96db619c235d9b5e5907c78ac3">nvtt::setMessageCallback</a></div><div class="ttdeci">NVTT_API bool setMessageCallback(MessageCallback callback, const void *userData)</div></div>
<div class="ttc" id="anamespacenvtt_html_ad1b50bb1a5bd8c44ab56092b30b9cd36"><div class="ttname"><a href="namespacenvtt.html#ad1b50bb1a5bd8c44ab56092b30b9cd36">nvtt::Error</a></div><div class="ttdeci">Error</div><div class="ttdoc">Error codes.</div><div class="ttdef"><b>Definition:</b> nvtt.h:293</div></div>
<div class="ttc" id="anamespacenvtt_html_adc828476883ed40499d01622d2a0873f"><div class="ttname"><a href="namespacenvtt.html#adc828476883ed40499d01622d2a0873f">nvtt::nvtt_encode_bc7</a></div><div class="ttdeci">void NVTT_API nvtt_encode_bc7(const CPUInputBuffer &amp;input, bool slow_mode, bool imageHasAlpha, void *output, bool useGpu=false, bool to_device_mem=false, nvtt::TimingContext *tc=nullptr)</div></div>
</div><!-- fragment --><p> Since each thread has its own callback pointer, a custom callback should be set whenever an app creates a new thread. If no callback has been set, the default callback prints the severity and the message, followed by a newline, to stdout. If a callback has been set, setting the callback to nullptr will make NVTT switch to the default callback. Returns true if setting the message callback succeeded. </p><dl class="section since"><dt>Since</dt><dd>NVTT 3.2 </dd></dl>

</div>
</div>
<a id="a4331c366610258762f80c8a3d7ee6910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4331c366610258762f80c8a3d7ee6910">&#9670;&nbsp;</a></span>useCurrentDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::useCurrentDevice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells NVTT to always use an application-set device rather than selecting its own. </p>
<p>By default, NVTT functions such as <a class="el" href="namespacenvtt.html#a07e1ba1bbab69167fca20f080ca9ce8e" title="Check if CUDA is supported by the run-time environment.">nvtt::isCudaSupported()</a> and <a class="el" href="structnvtt_1_1_context.html" title="Compression context.">nvtt::Context()</a> can choose a device and call cudaSetDevice(). Calling this function will prevent NVTT from calling cudaSetDevice(), and will make it use the currently set device instead. The application must then call cudaSetDevice() before calling NVTT functions, and whenever it wants to change the device subsequent NVTT functions will use.</p>
<p>For instance, this may be useful when managing devices on multi-GPU systems. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
