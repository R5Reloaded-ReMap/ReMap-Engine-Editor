<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nvtt: nvtt::Surface Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">nvtt
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenvtt.html">nvtt</a></li><li class="navelem"><a class="el" href="structnvtt_1_1_surface.html">Surface</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structnvtt_1_1_surface-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">nvtt::Surface Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A surface is one level of a 2D or 3D texture.  
 <a href="structnvtt_1_1_surface.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="nvtt_8h_source.html">nvtt.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa10fea1a1aaaa80aab8c2f8912152ea6"><td class="memItemLeft" align="right" valign="top"><a id="aa10fea1a1aaaa80aab8c2f8912152ea6"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#aa10fea1a1aaaa80aab8c2f8912152ea6">Surface</a> ()</td></tr>
<tr class="memdesc:aa10fea1a1aaaa80aab8c2f8912152ea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty surface. All data will be null until a <a class="el" href="structnvtt_1_1_surface.html#a5a47935fcb94952c439aa5a4e4d4f498" title="Sets this surface to a new w x h x d uninitialized image.">setImage()</a> function is called. <br /></td></tr>
<tr class="separator:aa10fea1a1aaaa80aab8c2f8912152ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d9d59fbb2f903f3cb06d27a8b5c539"><td class="memItemLeft" align="right" valign="top"><a id="ab3d9d59fbb2f903f3cb06d27a8b5c539"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#ab3d9d59fbb2f903f3cb06d27a8b5c539">Surface</a> (const <a class="el" href="structnvtt_1_1_surface.html">Surface</a> &amp;img)</td></tr>
<tr class="memdesc:ab3d9d59fbb2f903f3cb06d27a8b5c539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br /></td></tr>
<tr class="separator:ab3d9d59fbb2f903f3cb06d27a8b5c539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643c99ac5f1726e0a9396d89be2c4fb3"><td class="memItemLeft" align="right" valign="top"><a id="a643c99ac5f1726e0a9396d89be2c4fb3"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a643c99ac5f1726e0a9396d89be2c4fb3">~Surface</a> ()</td></tr>
<tr class="memdesc:a643c99ac5f1726e0a9396d89be2c4fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a643c99ac5f1726e0a9396d89be2c4fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079466281e2c845c167f57660d681970"><td class="memItemLeft" align="right" valign="top"><a id="a079466281e2c845c167f57660d681970"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a079466281e2c845c167f57660d681970">operator=</a> (const <a class="el" href="structnvtt_1_1_surface.html">Surface</a> &amp;img)</td></tr>
<tr class="memdesc:a079466281e2c845c167f57660d681970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator. <br /></td></tr>
<tr class="separator:a079466281e2c845c167f57660d681970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7715f4c5b9c06016055877dd31a39c99"><td class="memItemLeft" align="right" valign="top"><a id="a7715f4c5b9c06016055877dd31a39c99"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> <a class="el" href="structnvtt_1_1_surface.html">Surface</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a7715f4c5b9c06016055877dd31a39c99">clone</a> () const</td></tr>
<tr class="memdesc:a7715f4c5b9c06016055877dd31a39c99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a deep copy of this <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">Surface</a>, with its own internal data. (New in NVTT 3.1) <br /></td></tr>
<tr class="separator:a7715f4c5b9c06016055877dd31a39c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ce266053ecbb11a87835afa9acce54"><td class="memItemLeft" align="right" valign="top"><a id="a17ce266053ecbb11a87835afa9acce54"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a17ce266053ecbb11a87835afa9acce54">setWrapMode</a> (<a class="el" href="namespacenvtt.html#a04c40c16cdcde3c6c3f2e7081777a146">WrapMode</a> mode)</td></tr>
<tr class="memdesc:a17ce266053ecbb11a87835afa9acce54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">Surface</a>'s wrap mode. See <a class="el" href="namespacenvtt.html#a04c40c16cdcde3c6c3f2e7081777a146" title="Wrap modes. Specifies how to handle coordinates outside the typical image range.">WrapMode</a> for details. <br /></td></tr>
<tr class="separator:a17ce266053ecbb11a87835afa9acce54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e64b40ae34367071fb703da3bf71c2"><td class="memItemLeft" align="right" valign="top"><a id="ae6e64b40ae34367071fb703da3bf71c2"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#ae6e64b40ae34367071fb703da3bf71c2">setAlphaMode</a> (<a class="el" href="namespacenvtt.html#a258d3a85ebeb5cf05c98ce3b2441b172">AlphaMode</a> <a class="el" href="structnvtt_1_1_surface.html#a1ee2a5e77598e1801dbe683872fe1bae">alphaMode</a>)</td></tr>
<tr class="memdesc:ae6e64b40ae34367071fb703da3bf71c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">Surface</a>'s alpha mode. See <a class="el" href="namespacenvtt.html#a258d3a85ebeb5cf05c98ce3b2441b172" title="Alpha mode.">AlphaMode</a> for details. <br /></td></tr>
<tr class="separator:ae6e64b40ae34367071fb703da3bf71c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35ba609fa802c4685a9a488f8e5ef318"><td class="memItemLeft" align="right" valign="top"><a id="a35ba609fa802c4685a9a488f8e5ef318"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a35ba609fa802c4685a9a488f8e5ef318">setNormalMap</a> (bool <a class="el" href="structnvtt_1_1_surface.html#a625d336bfd75732460b6fa619116a178">isNormalMap</a>)</td></tr>
<tr class="memdesc:a35ba609fa802c4685a9a488f8e5ef318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether the <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">Surface</a> represents a normal map. This can be accessed using <a class="el" href="structnvtt_1_1_surface.html#a625d336bfd75732460b6fa619116a178" title="Returns whether the image represents a normal map. See setNormalMap()">isNormalMap()</a>, and e.g. affects whether DDS files are written with the normal map flag. <br /></td></tr>
<tr class="separator:a35ba609fa802c4685a9a488f8e5ef318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d06b99f9298acdcac222e8c48d49a0b"><td class="memItemLeft" align="right" valign="top"><a id="a3d06b99f9298acdcac222e8c48d49a0b"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a3d06b99f9298acdcac222e8c48d49a0b">isNull</a> () const</td></tr>
<tr class="memdesc:a3d06b99f9298acdcac222e8c48d49a0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the surface is null (i.e. refers to nothing, such as if it was just created using <a class="el" href="structnvtt_1_1_surface.html#aa10fea1a1aaaa80aab8c2f8912152ea6" title="Creates an empty surface. All data will be null until a setImage() function is called.">Surface()</a>). <br /></td></tr>
<tr class="separator:a3d06b99f9298acdcac222e8c48d49a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab766483595f4db56c7807bf0c81ed98c"><td class="memItemLeft" align="right" valign="top"><a id="ab766483595f4db56c7807bf0c81ed98c"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#ab766483595f4db56c7807bf0c81ed98c">width</a> () const</td></tr>
<tr class="memdesc:ab766483595f4db56c7807bf0c81ed98c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the width (X size) of the surface. <br /></td></tr>
<tr class="separator:ab766483595f4db56c7807bf0c81ed98c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a059d6eadb470e5b4209ad12e7c73309e"><td class="memItemLeft" align="right" valign="top"><a id="a059d6eadb470e5b4209ad12e7c73309e"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a059d6eadb470e5b4209ad12e7c73309e">height</a> () const</td></tr>
<tr class="memdesc:a059d6eadb470e5b4209ad12e7c73309e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the height (Y size) of the surface. <br /></td></tr>
<tr class="separator:a059d6eadb470e5b4209ad12e7c73309e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ceabda2b08248eecbe991b708ae52fb"><td class="memItemLeft" align="right" valign="top"><a id="a6ceabda2b08248eecbe991b708ae52fb"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a6ceabda2b08248eecbe991b708ae52fb">depth</a> () const</td></tr>
<tr class="memdesc:a6ceabda2b08248eecbe991b708ae52fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the depth (Z size) of the surface. 1 for 2D surfaces. <br /></td></tr>
<tr class="separator:a6ceabda2b08248eecbe991b708ae52fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d634b69971ab7e51897e08c0c1b54cc"><td class="memItemLeft" align="right" valign="top"><a id="a6d634b69971ab7e51897e08c0c1b54cc"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> <a class="el" href="namespacenvtt.html#a22da3a04bb7324cbd3919166b678b8e2">TextureType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a6d634b69971ab7e51897e08c0c1b54cc">type</a> () const</td></tr>
<tr class="memdesc:a6d634b69971ab7e51897e08c0c1b54cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dimensionality of the surface. This is set for instance by <a class="el" href="structnvtt_1_1_surface.html#a5a47935fcb94952c439aa5a4e4d4f498" title="Sets this surface to a new w x h x d uninitialized image.">setImage()</a>. <br /></td></tr>
<tr class="separator:a6d634b69971ab7e51897e08c0c1b54cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad00cb3a6c63bf4381960e19681177cec"><td class="memItemLeft" align="right" valign="top"><a id="ad00cb3a6c63bf4381960e19681177cec"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> <a class="el" href="namespacenvtt.html#a04c40c16cdcde3c6c3f2e7081777a146">WrapMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#ad00cb3a6c63bf4381960e19681177cec">wrapMode</a> () const</td></tr>
<tr class="memdesc:ad00cb3a6c63bf4381960e19681177cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the wrap mode of the surface. See <a class="el" href="structnvtt_1_1_surface.html#a17ce266053ecbb11a87835afa9acce54" title="Set the Surface&#39;s wrap mode. See WrapMode for details.">setWrapMode()</a> <br /></td></tr>
<tr class="separator:ad00cb3a6c63bf4381960e19681177cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee2a5e77598e1801dbe683872fe1bae"><td class="memItemLeft" align="right" valign="top"><a id="a1ee2a5e77598e1801dbe683872fe1bae"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> <a class="el" href="namespacenvtt.html#a258d3a85ebeb5cf05c98ce3b2441b172">AlphaMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a1ee2a5e77598e1801dbe683872fe1bae">alphaMode</a> () const</td></tr>
<tr class="memdesc:a1ee2a5e77598e1801dbe683872fe1bae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the alpha mode of the surface. See <a class="el" href="structnvtt_1_1_surface.html#ae6e64b40ae34367071fb703da3bf71c2" title="Set the Surface&#39;s alpha mode. See AlphaMode for details.">setAlphaMode()</a> <br /></td></tr>
<tr class="separator:a1ee2a5e77598e1801dbe683872fe1bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a625d336bfd75732460b6fa619116a178"><td class="memItemLeft" align="right" valign="top"><a id="a625d336bfd75732460b6fa619116a178"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a625d336bfd75732460b6fa619116a178">isNormalMap</a> () const</td></tr>
<tr class="memdesc:a625d336bfd75732460b6fa619116a178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the image represents a normal map. See <a class="el" href="structnvtt_1_1_surface.html#a35ba609fa802c4685a9a488f8e5ef318" title="Set whether the Surface represents a normal map. This can be accessed using isNormalMap(),...">setNormalMap()</a> <br /></td></tr>
<tr class="separator:a625d336bfd75732460b6fa619116a178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4de8d67b1fb1ac8a96ff1af239b436"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a9d4de8d67b1fb1ac8a96ff1af239b436">countMipmaps</a> () const</td></tr>
<tr class="memdesc:a9d4de8d67b1fb1ac8a96ff1af239b436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of mipmaps in a full mipmap chain. Each mip is half the size of the previous, rounding down, until and including a 1x1 mip.  <a href="structnvtt_1_1_surface.html#a9d4de8d67b1fb1ac8a96ff1af239b436">More...</a><br /></td></tr>
<tr class="separator:a9d4de8d67b1fb1ac8a96ff1af239b436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f3fd4ea1fd7e31dcfc1d6a6f81ad4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a85f3fd4ea1fd7e31dcfc1d6a6f81ad4a">countMipmaps</a> (int min_size) const</td></tr>
<tr class="memdesc:a85f3fd4ea1fd7e31dcfc1d6a6f81ad4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of mipmaps in a mipmap chain, stopping when <a class="el" href="structnvtt_1_1_surface.html#af3e981006d2b89d085f94f592d11d876" title="Returns whether a the surface would have a next mip in a mip chain with minimum size `min_size.">canMakeNextMipmap()</a> returns false.  <a href="structnvtt_1_1_surface.html#a85f3fd4ea1fd7e31dcfc1d6a6f81ad4a">More...</a><br /></td></tr>
<tr class="separator:a85f3fd4ea1fd7e31dcfc1d6a6f81ad4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b4cdb2773ea35b42ea460a2b4026cbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a3b4cdb2773ea35b42ea460a2b4026cbe">alphaTestCoverage</a> (float alphaRef=0.5, int alpha_channel=3) const</td></tr>
<tr class="memdesc:a3b4cdb2773ea35b42ea460a2b4026cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the approximate fraction (0 to 1) of the image with an alpha value greater than <code>alphaRef</code>.  <a href="structnvtt_1_1_surface.html#a3b4cdb2773ea35b42ea460a2b4026cbe">More...</a><br /></td></tr>
<tr class="separator:a3b4cdb2773ea35b42ea460a2b4026cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ed55dcc5f3f3d297e02872164be2d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#ae9ed55dcc5f3f3d297e02872164be2d5">average</a> (int <a class="el" href="structnvtt_1_1_surface.html#ab730fd435ee2f51defc87ef9aa749748">channel</a>, int alpha_channel=-1, float gamma=2.2f) const</td></tr>
<tr class="memdesc:ae9ed55dcc5f3f3d297e02872164be2d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of a channel, possibly with alpha or with a gamma transfer function.  <a href="structnvtt_1_1_surface.html#ae9ed55dcc5f3f3d297e02872164be2d5">More...</a><br /></td></tr>
<tr class="separator:ae9ed55dcc5f3f3d297e02872164be2d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d00fffaca7a69457c4db0a8af28fcd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> const float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a7d00fffaca7a69457c4db0a8af28fcd2">data</a> () const</td></tr>
<tr class="memdesc:a7d00fffaca7a69457c4db0a8af28fcd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code>const</code> pointer to the surface's CPU data.  <a href="structnvtt_1_1_surface.html#a7d00fffaca7a69457c4db0a8af28fcd2">More...</a><br /></td></tr>
<tr class="separator:a7d00fffaca7a69457c4db0a8af28fcd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab730fd435ee2f51defc87ef9aa749748"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> const float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#ab730fd435ee2f51defc87ef9aa749748">channel</a> (int i) const</td></tr>
<tr class="memdesc:ab730fd435ee2f51defc87ef9aa749748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code>const</code> pointer to channel i's CPU data.  <a href="structnvtt_1_1_surface.html#ab730fd435ee2f51defc87ef9aa749748">More...</a><br /></td></tr>
<tr class="separator:ab730fd435ee2f51defc87ef9aa749748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a9830d99707456c59a9b0658a33f5f"><td class="memItemLeft" align="right" valign="top"><a id="a09a9830d99707456c59a9b0658a33f5f"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a09a9830d99707456c59a9b0658a33f5f">data</a> ()</td></tr>
<tr class="memdesc:a09a9830d99707456c59a9b0658a33f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer that can be used to modify the surface's CPU data. See <a class="el" href="structnvtt_1_1_surface.html#a7d00fffaca7a69457c4db0a8af28fcd2" title="Returns a const pointer to the surface&#39;s CPU data.">data() const</a>. <br /></td></tr>
<tr class="separator:a09a9830d99707456c59a9b0658a33f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1183bc7aee37cb2a583ab272f9f3900"><td class="memItemLeft" align="right" valign="top"><a id="ab1183bc7aee37cb2a583ab272f9f3900"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#ab1183bc7aee37cb2a583ab272f9f3900">channel</a> (int i)</td></tr>
<tr class="memdesc:ab1183bc7aee37cb2a583ab272f9f3900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer that can be used to modify channel i's CPU data. See <a class="el" href="structnvtt_1_1_surface.html#ab730fd435ee2f51defc87ef9aa749748" title="Returns a const pointer to channel i&#39;s CPU data.">channel(int) const</a>. <br /></td></tr>
<tr class="separator:ab1183bc7aee37cb2a583ab272f9f3900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a315247163465480bfc38c9a63a4f4e3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a315247163465480bfc38c9a63a4f4e3a">histogram</a> (int <a class="el" href="structnvtt_1_1_surface.html#ab730fd435ee2f51defc87ef9aa749748">channel</a>, float rangeMin, float rangeMax, int binCount, int *binPtr, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0) const</td></tr>
<tr class="memdesc:a315247163465480bfc38c9a63a4f4e3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a histogram of channel values between <code>rangeMin</code> and <code>rangeMax</code> into <code>binPtr[0...binCount-1]</code>.  <a href="structnvtt_1_1_surface.html#a315247163465480bfc38c9a63a4f4e3a">More...</a><br /></td></tr>
<tr class="separator:a315247163465480bfc38c9a63a4f4e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc8a14675ef0cbc891bfe839d29a1c29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#afc8a14675ef0cbc891bfe839d29a1c29">range</a> (int <a class="el" href="structnvtt_1_1_surface.html#ab730fd435ee2f51defc87ef9aa749748">channel</a>, float *rangeMin, float *rangeMax, int alpha_channel=-1, float alpha_ref=0.f, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0) const</td></tr>
<tr class="memdesc:afc8a14675ef0cbc891bfe839d29a1c29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code>*rangeMin</code> and <code>*rangeMax</code> to the range of values in the channel, possibly using alpha testing.  <a href="structnvtt_1_1_surface.html#afc8a14675ef0cbc891bfe839d29a1c29">More...</a><br /></td></tr>
<tr class="separator:afc8a14675ef0cbc891bfe839d29a1c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7162b072976c0134a3854df107c2b7d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a7162b072976c0134a3854df107c2b7d5">load</a> (const char *fileName, bool *hasAlpha=0, bool expectSigned=false, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a7162b072976c0134a3854df107c2b7d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads texture data from a file.  <a href="structnvtt_1_1_surface.html#a7162b072976c0134a3854df107c2b7d5">More...</a><br /></td></tr>
<tr class="separator:a7162b072976c0134a3854df107c2b7d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a779543e6e00e503a8734b1281ff25b5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a779543e6e00e503a8734b1281ff25b5b">loadFromMemory</a> (const void *<a class="el" href="structnvtt_1_1_surface.html#a7d00fffaca7a69457c4db0a8af28fcd2">data</a>, unsigned long long sizeInBytes, bool *hasAlpha=0, bool expectSigned=false, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a779543e6e00e503a8734b1281ff25b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of <a class="el" href="structnvtt_1_1_surface.html#a7162b072976c0134a3854df107c2b7d5" title="Loads texture data from a file.">load()</a> that reads from memory instead of a file.  <a href="structnvtt_1_1_surface.html#a779543e6e00e503a8734b1281ff25b5b">More...</a><br /></td></tr>
<tr class="separator:a779543e6e00e503a8734b1281ff25b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a103d5b57c7153ceb77f23a3d9714c706"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a103d5b57c7153ceb77f23a3d9714c706">save</a> (const char *fileName, bool hasAlpha=false, bool hdr=false, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0) const</td></tr>
<tr class="memdesc:a103d5b57c7153ceb77f23a3d9714c706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves texture data to file.  <a href="structnvtt_1_1_surface.html#a103d5b57c7153ceb77f23a3d9714c706">More...</a><br /></td></tr>
<tr class="separator:a103d5b57c7153ceb77f23a3d9714c706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a47935fcb94952c439aa5a4e4d4f498"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a5a47935fcb94952c439aa5a4e4d4f498">setImage</a> (int w, int h, int d, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a5a47935fcb94952c439aa5a4e4d4f498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this surface to a new w x h x d uninitialized image.  <a href="structnvtt_1_1_surface.html#a5a47935fcb94952c439aa5a4e4d4f498">More...</a><br /></td></tr>
<tr class="separator:a5a47935fcb94952c439aa5a4e4d4f498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1f88d67c313490b2ed042c240b718c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#ab1f88d67c313490b2ed042c240b718c2">setImage</a> (<a class="el" href="namespacenvtt.html#a7ea4cd82d5104d66e14f5524442c5f5e">InputFormat</a> format, int w, int h, int d, const void *<a class="el" href="structnvtt_1_1_surface.html#a7d00fffaca7a69457c4db0a8af28fcd2">data</a>, bool unsignedToSigned=false, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:ab1f88d67c313490b2ed042c240b718c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this surface given uncompressed input data.  <a href="structnvtt_1_1_surface.html#ab1f88d67c313490b2ed042c240b718c2">More...</a><br /></td></tr>
<tr class="separator:ab1f88d67c313490b2ed042c240b718c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6575c5667cd8654ee9d224075f5e3576"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a6575c5667cd8654ee9d224075f5e3576">setImage</a> (<a class="el" href="namespacenvtt.html#a7ea4cd82d5104d66e14f5524442c5f5e">InputFormat</a> format, int w, int h, int d, const void *r, const void *g, const void *b, const void *a, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a6575c5667cd8654ee9d224075f5e3576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this surface given uncompressed input data, with different pointers for each channel.  <a href="structnvtt_1_1_surface.html#a6575c5667cd8654ee9d224075f5e3576">More...</a><br /></td></tr>
<tr class="separator:a6575c5667cd8654ee9d224075f5e3576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a687a3504eeba283366e36315904aeb"><td class="memItemLeft" align="right" valign="top"><a id="a4a687a3504eeba283366e36315904aeb"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a4a687a3504eeba283366e36315904aeb">setImage2D</a> (<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6d">Format</a> format, int w, int h, const void *<a class="el" href="structnvtt_1_1_surface.html#a7d00fffaca7a69457c4db0a8af28fcd2">data</a>, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a4a687a3504eeba283366e36315904aeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set 2D surface values from an encoded data source. Same as <a class="el" href="structnvtt_1_1_surface.html#a2aed8c61f05336b7eab8b2e1431ccc65" title="Set surface values from an encoded data source.">setImage3D()</a> with <code>d=1</code>. <br /></td></tr>
<tr class="separator:a4a687a3504eeba283366e36315904aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aed8c61f05336b7eab8b2e1431ccc65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a2aed8c61f05336b7eab8b2e1431ccc65">setImage3D</a> (<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6d">Format</a> format, int w, int h, int d, const void *<a class="el" href="structnvtt_1_1_surface.html#a7d00fffaca7a69457c4db0a8af28fcd2">data</a>, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a2aed8c61f05336b7eab8b2e1431ccc65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set surface values from an encoded data source.  <a href="structnvtt_1_1_surface.html#a2aed8c61f05336b7eab8b2e1431ccc65">More...</a><br /></td></tr>
<tr class="separator:a2aed8c61f05336b7eab8b2e1431ccc65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b2bd544a72fb7c60e0106c6f870893"><td class="memItemLeft" align="right" valign="top"><a id="aa8b2bd544a72fb7c60e0106c6f870893"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#aa8b2bd544a72fb7c60e0106c6f870893">resize</a> (int w, int h, int d, <a class="el" href="namespacenvtt.html#a3607100ce561fdaa3859abd0f05878c7">ResizeFilter</a> filter, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:aa8b2bd544a72fb7c60e0106c6f870893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes this surface to have size w x h x d using a given filter. <br /></td></tr>
<tr class="separator:aa8b2bd544a72fb7c60e0106c6f870893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a013d651c695516e8fdbdf7634573918a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a013d651c695516e8fdbdf7634573918a">resize</a> (int w, int h, int d, <a class="el" href="namespacenvtt.html#a3607100ce561fdaa3859abd0f05878c7">ResizeFilter</a> filter, float filterWidth, const float *params=0, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="separator:a013d651c695516e8fdbdf7634573918a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac459aa4c41f41ec0f615b6352e3262c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#ac459aa4c41f41ec0f615b6352e3262c2">resize</a> (int maxExtent, <a class="el" href="namespacenvtt.html#a673a22796ec42ae50e14ab1ed6906bd5">RoundMode</a> mode, <a class="el" href="namespacenvtt.html#a3607100ce561fdaa3859abd0f05878c7">ResizeFilter</a> filter, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:ac459aa4c41f41ec0f615b6352e3262c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes this surface so that its largest side has length <code>maxExtent</code>, subject to a rounding mode.  <a href="structnvtt_1_1_surface.html#ac459aa4c41f41ec0f615b6352e3262c2">More...</a><br /></td></tr>
<tr class="separator:ac459aa4c41f41ec0f615b6352e3262c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f66cd503c0b7fd8667cfc7acca170e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a6f66cd503c0b7fd8667cfc7acca170e4">resize</a> (int maxExtent, <a class="el" href="namespacenvtt.html#a673a22796ec42ae50e14ab1ed6906bd5">RoundMode</a> mode, <a class="el" href="namespacenvtt.html#a3607100ce561fdaa3859abd0f05878c7">ResizeFilter</a> filter, float filterWidth, const float *params=0, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a6f66cd503c0b7fd8667cfc7acca170e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes this surface so that its largest side has length <code>maxExtent</code>, subject to a rounding mode, using customizable filter parameters.  <a href="structnvtt_1_1_surface.html#a6f66cd503c0b7fd8667cfc7acca170e4">More...</a><br /></td></tr>
<tr class="separator:a6f66cd503c0b7fd8667cfc7acca170e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84c67783861084298893fa54f031624"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#af84c67783861084298893fa54f031624">resize_make_square</a> (int maxExtent, <a class="el" href="namespacenvtt.html#a673a22796ec42ae50e14ab1ed6906bd5">RoundMode</a> roundMode, <a class="el" href="namespacenvtt.html#a3607100ce561fdaa3859abd0f05878c7">ResizeFilter</a> filter, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:af84c67783861084298893fa54f031624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes this surface so that its longest side has length <code>maxExtent</code> and the result is square or cubical.  <a href="structnvtt_1_1_surface.html#af84c67783861084298893fa54f031624">More...</a><br /></td></tr>
<tr class="separator:af84c67783861084298893fa54f031624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85e9ae8132a60fcf923300687af2778"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#ab85e9ae8132a60fcf923300687af2778">buildNextMipmap</a> (<a class="el" href="namespacenvtt.html#a28d4701da3f4e6935956949dab69c479">MipmapFilter</a> filter, int min_size=1, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:ab85e9ae8132a60fcf923300687af2778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes this surface to create the next mip in a mipmap chain.  <a href="structnvtt_1_1_surface.html#ab85e9ae8132a60fcf923300687af2778">More...</a><br /></td></tr>
<tr class="separator:ab85e9ae8132a60fcf923300687af2778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbedd7b081d94ca7641d33453c3b96ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#afbedd7b081d94ca7641d33453c3b96ed">buildNextMipmap</a> (<a class="el" href="namespacenvtt.html#a28d4701da3f4e6935956949dab69c479">MipmapFilter</a> filter, float filterWidth, const float *params=0, int min_size=1, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:afbedd7b081d94ca7641d33453c3b96ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of <a class="el" href="structnvtt_1_1_surface.html#ab85e9ae8132a60fcf923300687af2778" title="Resizes this surface to create the next mip in a mipmap chain.">buildNextMipmap(MipmapFilter, int, TimingContext*)</a> with customizable parameters.  <a href="structnvtt_1_1_surface.html#afbedd7b081d94ca7641d33453c3b96ed">More...</a><br /></td></tr>
<tr class="separator:afbedd7b081d94ca7641d33453c3b96ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d48d0db77b102facf116ceb2d751371"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a4d48d0db77b102facf116ceb2d751371">buildNextMipmapSolidColor</a> (const float *const color_components, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a4d48d0db77b102facf116ceb2d751371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces this surface with a surface the size of the next mip in a mip chain (half the width and height), but with each channel cleared to a constant value.  <a href="structnvtt_1_1_surface.html#a4d48d0db77b102facf116ceb2d751371">More...</a><br /></td></tr>
<tr class="separator:a4d48d0db77b102facf116ceb2d751371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d5328cdb2d5bf98aeece3a19b8addf0"><td class="memItemLeft" align="right" valign="top"><a id="a3d5328cdb2d5bf98aeece3a19b8addf0"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a3d5328cdb2d5bf98aeece3a19b8addf0">canvasSize</a> (int w, int h, int d, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a3d5328cdb2d5bf98aeece3a19b8addf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Crops or expands this surface from the (0,0,0) corner, with any new values cleared to 0. <br /></td></tr>
<tr class="separator:a3d5328cdb2d5bf98aeece3a19b8addf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e981006d2b89d085f94f592d11d876"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#af3e981006d2b89d085f94f592d11d876">canMakeNextMipmap</a> (int min_size=1)</td></tr>
<tr class="memdesc:af3e981006d2b89d085f94f592d11d876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a the surface would have a next mip in a mip chain with minimum size `min_size.  <a href="structnvtt_1_1_surface.html#af3e981006d2b89d085f94f592d11d876">More...</a><br /></td></tr>
<tr class="separator:af3e981006d2b89d085f94f592d11d876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb44e96cba47c376b117c55380c59df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a5fb44e96cba47c376b117c55380c59df">toLinear</a> (float gamma, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a5fb44e96cba47c376b117c55380c59df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raises channels 0...2 to the power <code>gamma</code>.  <a href="structnvtt_1_1_surface.html#a5fb44e96cba47c376b117c55380c59df">More...</a><br /></td></tr>
<tr class="separator:a5fb44e96cba47c376b117c55380c59df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b256ef10f8640189647d04ab7131188"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a6b256ef10f8640189647d04ab7131188">toGamma</a> (float gamma, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a6b256ef10f8640189647d04ab7131188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raises channels 0...2 to the power <code>1/gamma</code>.  <a href="structnvtt_1_1_surface.html#a6b256ef10f8640189647d04ab7131188">More...</a><br /></td></tr>
<tr class="separator:a6b256ef10f8640189647d04ab7131188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88333478a4689b0548036cae534a7b8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a88333478a4689b0548036cae534a7b8c">toLinear</a> (int <a class="el" href="structnvtt_1_1_surface.html#ab730fd435ee2f51defc87ef9aa749748">channel</a>, float gamma, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a88333478a4689b0548036cae534a7b8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raises the given channel to the power <code>gamma</code>.  <a href="structnvtt_1_1_surface.html#a88333478a4689b0548036cae534a7b8c">More...</a><br /></td></tr>
<tr class="separator:a88333478a4689b0548036cae534a7b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af796ccf711307fbbec4a2150612536f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#af796ccf711307fbbec4a2150612536f8">toGamma</a> (int <a class="el" href="structnvtt_1_1_surface.html#ab730fd435ee2f51defc87ef9aa749748">channel</a>, float gamma, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:af796ccf711307fbbec4a2150612536f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raises the given channel to the power <code>1/gamma</code>.  <a href="structnvtt_1_1_surface.html#af796ccf711307fbbec4a2150612536f8">More...</a><br /></td></tr>
<tr class="separator:af796ccf711307fbbec4a2150612536f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17627047b1633a02c1d78e8de403bb6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a17627047b1633a02c1d78e8de403bb6a">toSrgb</a> (<a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a17627047b1633a02c1d78e8de403bb6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the linear-to-sRGB transfer function to channels 0...2.  <a href="structnvtt_1_1_surface.html#a17627047b1633a02c1d78e8de403bb6a">More...</a><br /></td></tr>
<tr class="separator:a17627047b1633a02c1d78e8de403bb6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcce47cfb9450d88f90415a937746a00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#afcce47cfb9450d88f90415a937746a00">toSrgbUnclamped</a> (<a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:afcce47cfb9450d88f90415a937746a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the linear-to-sRGB transfer function to channels 0...2, but does not clamp output to [0,1].  <a href="structnvtt_1_1_surface.html#afcce47cfb9450d88f90415a937746a00">More...</a><br /></td></tr>
<tr class="separator:afcce47cfb9450d88f90415a937746a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80080f94846613535e5e7abbb61a8a7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a80080f94846613535e5e7abbb61a8a7e">toLinearFromSrgb</a> (<a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a80080f94846613535e5e7abbb61a8a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the sRGB-to-linear transfer function to channels 0...2.  <a href="structnvtt_1_1_surface.html#a80080f94846613535e5e7abbb61a8a7e">More...</a><br /></td></tr>
<tr class="separator:a80080f94846613535e5e7abbb61a8a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b859aa7259a5283eaabc3e7680d2cd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a7b859aa7259a5283eaabc3e7680d2cd9">toLinearFromSrgbUnclamped</a> (<a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a7b859aa7259a5283eaabc3e7680d2cd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the sRGB-to-linear transfer function to channels 0...2, but does not clamp output to [0,1].  <a href="structnvtt_1_1_surface.html#a7b859aa7259a5283eaabc3e7680d2cd9">More...</a><br /></td></tr>
<tr class="separator:a7b859aa7259a5283eaabc3e7680d2cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b196745118c02562e7e9cfe017e3f33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a7b196745118c02562e7e9cfe017e3f33">toXenonSrgb</a> (<a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a7b196745118c02562e7e9cfe017e3f33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts colors in channels 0...2 from linear to a piecewise linear sRGB approximation.  <a href="structnvtt_1_1_surface.html#a7b196745118c02562e7e9cfe017e3f33">More...</a><br /></td></tr>
<tr class="separator:a7b196745118c02562e7e9cfe017e3f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8c197a640f3e5ee8c21eb5b2616143"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a2c8c197a640f3e5ee8c21eb5b2616143">toLinearFromXenonSrgb</a> (<a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a2c8c197a640f3e5ee8c21eb5b2616143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts colors in channels 0...2 from the Xenon sRGB piecewise linear sRGB approximation to linear.  <a href="structnvtt_1_1_surface.html#a2c8c197a640f3e5ee8c21eb5b2616143">More...</a><br /></td></tr>
<tr class="separator:a2c8c197a640f3e5ee8c21eb5b2616143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1b394127ba32bbe97cf0ca6565dfab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a8b1b394127ba32bbe97cf0ca6565dfab">transform</a> (const float w0[4], const float w1[4], const float w2[4], const float w3[4], const float offset[4], <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a8b1b394127ba32bbe97cf0ca6565dfab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a 4x4 affine transformation to the values in channels 0...3.  <a href="structnvtt_1_1_surface.html#a8b1b394127ba32bbe97cf0ca6565dfab">More...</a><br /></td></tr>
<tr class="separator:a8b1b394127ba32bbe97cf0ca6565dfab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70bff140663fe8f026a5bc73098a7ce3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a70bff140663fe8f026a5bc73098a7ce3">swizzle</a> (int r, int g, int b, int a, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a70bff140663fe8f026a5bc73098a7ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swizzles the channels of the surface.  <a href="structnvtt_1_1_surface.html#a70bff140663fe8f026a5bc73098a7ce3">More...</a><br /></td></tr>
<tr class="separator:a70bff140663fe8f026a5bc73098a7ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd655f7ec1760246f43bf2b34ed1b6b0"><td class="memItemLeft" align="right" valign="top"><a id="abd655f7ec1760246f43bf2b34ed1b6b0"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#abd655f7ec1760246f43bf2b34ed1b6b0">scaleBias</a> (int <a class="el" href="structnvtt_1_1_surface.html#ab730fd435ee2f51defc87ef9aa749748">channel</a>, float scale, float bias, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:abd655f7ec1760246f43bf2b34ed1b6b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a scale and bias to the given channel. Each value x is replaced by x * scale + bias. <br /></td></tr>
<tr class="separator:abd655f7ec1760246f43bf2b34ed1b6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15fbdad22c78954265de6d1a1cfa925"><td class="memItemLeft" align="right" valign="top"><a id="ae15fbdad22c78954265de6d1a1cfa925"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#ae15fbdad22c78954265de6d1a1cfa925">clamp</a> (int <a class="el" href="structnvtt_1_1_surface.html#ab730fd435ee2f51defc87ef9aa749748">channel</a>, float low=0.0f, float high=1.0f, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:ae15fbdad22c78954265de6d1a1cfa925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clamps all values in the channel to the range [low, high]. <br /></td></tr>
<tr class="separator:ae15fbdad22c78954265de6d1a1cfa925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d369d23a1d438f49f120515d6343952"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a0d369d23a1d438f49f120515d6343952">blend</a> (float r, float g, float b, float a, float t, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a0d369d23a1d438f49f120515d6343952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolates all texels between their current color and a constant color <code>(r, g, b, a)</code>.  <a href="structnvtt_1_1_surface.html#a0d369d23a1d438f49f120515d6343952">More...</a><br /></td></tr>
<tr class="separator:a0d369d23a1d438f49f120515d6343952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf3bba837ea826fdf107a9c46935854"><td class="memItemLeft" align="right" valign="top"><a id="a4cf3bba837ea826fdf107a9c46935854"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a4cf3bba837ea826fdf107a9c46935854">premultiplyAlpha</a> (<a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a4cf3bba837ea826fdf107a9c46935854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts to premultiplied alpha, replacing <code>(r, g, b, a)</code> with <code>(ar, ag, ab, a)</code>. <br /></td></tr>
<tr class="separator:a4cf3bba837ea826fdf107a9c46935854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a907f237e7825d33836d253f21fca2274"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a907f237e7825d33836d253f21fca2274">demultiplyAlpha</a> (float epsilon=1e-12f, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a907f237e7825d33836d253f21fca2274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts from premultiplied to unpremultiplied alpha, with special handling around zero alpha values.  <a href="structnvtt_1_1_surface.html#a907f237e7825d33836d253f21fca2274">More...</a><br /></td></tr>
<tr class="separator:a907f237e7825d33836d253f21fca2274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf34d2e2d64895e2f8983b6bb12f7fb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#adf34d2e2d64895e2f8983b6bb12f7fb6">toGreyScale</a> (float redScale, float greenScale, float blueScale, float alphaScale, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:adf34d2e2d64895e2f8983b6bb12f7fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets channels 0...3 to the result of converting to grayscale, with customizable channel weights.  <a href="structnvtt_1_1_surface.html#adf34d2e2d64895e2f8983b6bb12f7fb6">More...</a><br /></td></tr>
<tr class="separator:adf34d2e2d64895e2f8983b6bb12f7fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab9d4dd6347e226591bdefa18c4ebd6"><td class="memItemLeft" align="right" valign="top"><a id="adab9d4dd6347e226591bdefa18c4ebd6"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#adab9d4dd6347e226591bdefa18c4ebd6">setBorder</a> (float r, float g, float b, float a, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:adab9d4dd6347e226591bdefa18c4ebd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all texels on the border of the surface to a solid color. <br /></td></tr>
<tr class="separator:adab9d4dd6347e226591bdefa18c4ebd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dbd1c849660a8e7569ea474254c4369"><td class="memItemLeft" align="right" valign="top"><a id="a9dbd1c849660a8e7569ea474254c4369"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a9dbd1c849660a8e7569ea474254c4369">fill</a> (float r, float g, float b, float a, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a9dbd1c849660a8e7569ea474254c4369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all texels in the surface to a solid color. <br /></td></tr>
<tr class="separator:a9dbd1c849660a8e7569ea474254c4369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde10e16c748638b70b81a7cc0b3456c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#afde10e16c748638b70b81a7cc0b3456c">scaleAlphaToCoverage</a> (float coverage, float alphaRef=0.5f, int alpha_channel=3, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:afde10e16c748638b70b81a7cc0b3456c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to scale the alpha channel so that a fraction <code>coverage</code> (between 0 and 1) of the surface has an alpha greater than <code>alphaRef</code>.  <a href="structnvtt_1_1_surface.html#afde10e16c748638b70b81a7cc0b3456c">More...</a><br /></td></tr>
<tr class="separator:afde10e16c748638b70b81a7cc0b3456c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae49d2c1546b1c1f4c92798d068906574"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#ae49d2c1546b1c1f4c92798d068906574">toRGBM</a> (float <a class="el" href="structnvtt_1_1_surface.html#afc8a14675ef0cbc891bfe839d29a1c29">range</a>=1.0f, float threshold=0.25f, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:ae49d2c1546b1c1f4c92798d068906574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces an LDR Red, Green, Blue, Magnitude encoding of the HDR RGB channels.  <a href="structnvtt_1_1_surface.html#ae49d2c1546b1c1f4c92798d068906574">More...</a><br /></td></tr>
<tr class="separator:ae49d2c1546b1c1f4c92798d068906574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ee98276a237caf39437f5aa64730e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a37ee98276a237caf39437f5aa64730e0">fromRGBM</a> (float <a class="el" href="structnvtt_1_1_surface.html#afc8a14675ef0cbc891bfe839d29a1c29">range</a>=1.0f, float threshold=0.25f, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a37ee98276a237caf39437f5aa64730e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces HDR <code>(r, g, b, 1)</code> values from an LDR <code>(red, green, blue, magnitude)</code> storage method.  <a href="structnvtt_1_1_surface.html#a37ee98276a237caf39437f5aa64730e0">More...</a><br /></td></tr>
<tr class="separator:a37ee98276a237caf39437f5aa64730e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3c65e88161fa460176805370b47653"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a1e3c65e88161fa460176805370b47653">toLM</a> (float <a class="el" href="structnvtt_1_1_surface.html#afc8a14675ef0cbc891bfe839d29a1c29">range</a>=1.0f, float threshold=0.0f, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a1e3c65e88161fa460176805370b47653"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores luminance-only values in a two-channel way. Maybe consider BC4 compression instead.  <a href="structnvtt_1_1_surface.html#a1e3c65e88161fa460176805370b47653">More...</a><br /></td></tr>
<tr class="separator:a1e3c65e88161fa460176805370b47653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22a21fb2c5a0b73cadf905a90df96ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#ab22a21fb2c5a0b73cadf905a90df96ec">toRGBE</a> (int mantissaBits, int exponentBits, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:ab22a21fb2c5a0b73cadf905a90df96ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces a shared-exponent Red, Green, Blue, Exponent encoding of the HDR RGB channels, such as R9G9B9E5.  <a href="structnvtt_1_1_surface.html#ab22a21fb2c5a0b73cadf905a90df96ec">More...</a><br /></td></tr>
<tr class="separator:ab22a21fb2c5a0b73cadf905a90df96ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac739fbfff5eb5237ca7d3635477681cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#ac739fbfff5eb5237ca7d3635477681cc">fromRGBE</a> (int mantissaBits, int exponentBits, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:ac739fbfff5eb5237ca7d3635477681cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces HDR <code>(r, g, b, 1)</code> values from an LDR <code>(red, green, blue, exponent)</code> storage method.  <a href="structnvtt_1_1_surface.html#ac739fbfff5eb5237ca7d3635477681cc">More...</a><br /></td></tr>
<tr class="separator:ac739fbfff5eb5237ca7d3635477681cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b5be8a1824b6927fdbb42c5e19d7d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a11b5be8a1824b6927fdbb42c5e19d7d9">toYCoCg</a> (<a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a11b5be8a1824b6927fdbb42c5e19d7d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts from <code>(r, g, b, -)</code> colors to <code>(Co, Cg, 1, Y)</code> colors.  <a href="structnvtt_1_1_surface.html#a11b5be8a1824b6927fdbb42c5e19d7d9">More...</a><br /></td></tr>
<tr class="separator:a11b5be8a1824b6927fdbb42c5e19d7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afccc1a72d64b4c92fa98f746c700704e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#afccc1a72d64b4c92fa98f746c700704e">blockScaleCoCg</a> (int bits=5, float threshold=0.0f, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:afccc1a72d64b4c92fa98f746c700704e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores per-block YCoCg scaling information for potentially better 4-channel compression of YCoCg data.  <a href="structnvtt_1_1_surface.html#afccc1a72d64b4c92fa98f746c700704e">More...</a><br /></td></tr>
<tr class="separator:afccc1a72d64b4c92fa98f746c700704e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04bb71ed43deb8454491d554ac2e3145"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a04bb71ed43deb8454491d554ac2e3145">fromYCoCg</a> (<a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a04bb71ed43deb8454491d554ac2e3145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts from <code>(Co, Cg, scale, Y)</code> colors to <code>(r, g, b, 1)</code> colors.  <a href="structnvtt_1_1_surface.html#a04bb71ed43deb8454491d554ac2e3145">More...</a><br /></td></tr>
<tr class="separator:a04bb71ed43deb8454491d554ac2e3145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab042fa04f955079c069a5161ed2c3135"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#ab042fa04f955079c069a5161ed2c3135">toLUVW</a> (float <a class="el" href="structnvtt_1_1_surface.html#afc8a14675ef0cbc891bfe839d29a1c29">range</a>=1.0f, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:ab042fa04f955079c069a5161ed2c3135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts from RGB colors to a (U, V, W, L) color space, much like RGBM.  <a href="structnvtt_1_1_surface.html#ab042fa04f955079c069a5161ed2c3135">More...</a><br /></td></tr>
<tr class="separator:ab042fa04f955079c069a5161ed2c3135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44e3a7cbb1ab51b47ba7897563de5323"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a44e3a7cbb1ab51b47ba7897563de5323">fromLUVW</a> (float <a class="el" href="structnvtt_1_1_surface.html#afc8a14675ef0cbc891bfe839d29a1c29">range</a>=1.0f, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a44e3a7cbb1ab51b47ba7897563de5323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts from <a class="el" href="structnvtt_1_1_surface.html#ab042fa04f955079c069a5161ed2c3135" title="Converts from RGB colors to a (U, V, W, L) color space, much like RGBM.">toLUVW()</a>'s color space to RGB colors.  <a href="structnvtt_1_1_surface.html#a44e3a7cbb1ab51b47ba7897563de5323">More...</a><br /></td></tr>
<tr class="separator:a44e3a7cbb1ab51b47ba7897563de5323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a737d13712fa657adb92a2bbb4e6619c6"><td class="memItemLeft" align="right" valign="top"><a id="a737d13712fa657adb92a2bbb4e6619c6"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a737d13712fa657adb92a2bbb4e6619c6">abs</a> (int <a class="el" href="structnvtt_1_1_surface.html#ab730fd435ee2f51defc87ef9aa749748">channel</a>, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a737d13712fa657adb92a2bbb4e6619c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all colors by their absolute value. <br /></td></tr>
<tr class="separator:a737d13712fa657adb92a2bbb4e6619c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2db053835be6f1060c414e46d34385db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a2db053835be6f1060c414e46d34385db">convolve</a> (int <a class="el" href="structnvtt_1_1_surface.html#ab730fd435ee2f51defc87ef9aa749748">channel</a>, int kernelSize, float *kernelData, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a2db053835be6f1060c414e46d34385db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolves a channel with a kernel.  <a href="structnvtt_1_1_surface.html#a2db053835be6f1060c414e46d34385db">More...</a><br /></td></tr>
<tr class="separator:a2db053835be6f1060c414e46d34385db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7379a70c981eca546153b10832ca3335"><td class="memItemLeft" align="right" valign="top"><a id="a7379a70c981eca546153b10832ca3335"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a7379a70c981eca546153b10832ca3335">toLogScale</a> (int <a class="el" href="structnvtt_1_1_surface.html#ab730fd435ee2f51defc87ef9aa749748">channel</a>, float base, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a7379a70c981eca546153b10832ca3335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all values with their log with the given base. <br /></td></tr>
<tr class="separator:a7379a70c981eca546153b10832ca3335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ab44e1c6517847018f2402c914260a"><td class="memItemLeft" align="right" valign="top"><a id="a86ab44e1c6517847018f2402c914260a"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a86ab44e1c6517847018f2402c914260a">fromLogScale</a> (int <a class="el" href="structnvtt_1_1_surface.html#ab730fd435ee2f51defc87ef9aa749748">channel</a>, float base, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a86ab44e1c6517847018f2402c914260a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts <a class="el" href="structnvtt_1_1_surface.html#a7379a70c981eca546153b10832ca3335" title="Replaces all values with their log with the given base.">toLogScale()</a> by replacing all values <code>x</code> with <code>base^x</code>. <br /></td></tr>
<tr class="separator:a86ab44e1c6517847018f2402c914260a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f9bb8a615b9b4b583c89ae47b1f08a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a03f9bb8a615b9b4b583c89ae47b1f08a">setAtlasBorder</a> (int w, int h, float r, float g, float b, float a, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a03f9bb8a615b9b4b583c89ae47b1f08a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws borders of a given color around each w x h tile contained within the surface, starting from the (0, 0) corner.  <a href="structnvtt_1_1_surface.html#a03f9bb8a615b9b4b583c89ae47b1f08a">More...</a><br /></td></tr>
<tr class="separator:a03f9bb8a615b9b4b583c89ae47b1f08a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43fc10ca72b55a14abaec47e0264314e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a43fc10ca72b55a14abaec47e0264314e">toneMap</a> (<a class="el" href="namespacenvtt.html#a30709ef62a9d666f2be7f34cce8e3b94">ToneMapper</a> tm, float *parameters, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a43fc10ca72b55a14abaec47e0264314e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an HDR-to-LDR tone mapper.  <a href="structnvtt_1_1_surface.html#a43fc10ca72b55a14abaec47e0264314e">More...</a><br /></td></tr>
<tr class="separator:a43fc10ca72b55a14abaec47e0264314e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a0f61ae151ef04bd250d57f8987b592"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a4a0f61ae151ef04bd250d57f8987b592">binarize</a> (int <a class="el" href="structnvtt_1_1_surface.html#ab730fd435ee2f51defc87ef9aa749748">channel</a>, float threshold, bool dither, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a4a0f61ae151ef04bd250d57f8987b592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets values in the given channel to either 1 or 0 depending on if they're greater than the threshold, with optional dithering.  <a href="structnvtt_1_1_surface.html#a4a0f61ae151ef04bd250d57f8987b592">More...</a><br /></td></tr>
<tr class="separator:a4a0f61ae151ef04bd250d57f8987b592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4fd978431757e6b3f4c1e6e114ffc40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#ad4fd978431757e6b3f4c1e6e114ffc40">quantize</a> (int <a class="el" href="structnvtt_1_1_surface.html#ab730fd435ee2f51defc87ef9aa749748">channel</a>, int bits, bool exactEndPoints, bool dither, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:ad4fd978431757e6b3f4c1e6e114ffc40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quantizes this channel to a particular number of bits, with optional dithering.  <a href="structnvtt_1_1_surface.html#ad4fd978431757e6b3f4c1e6e114ffc40">More...</a><br /></td></tr>
<tr class="separator:ad4fd978431757e6b3f4c1e6e114ffc40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b7f9167b3996bf7228daf6c894993b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#ab9b7f9167b3996bf7228daf6c894993b">toNormalMap</a> (float sm, float medium, float big, float large, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:ab9b7f9167b3996bf7228daf6c894993b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the RGB channels to a normal map generated by interpreting the alpha channel as a heightmap, using a blend of four small-scale to large-scale Sobel kernels.  <a href="structnvtt_1_1_surface.html#ab9b7f9167b3996bf7228daf6c894993b">More...</a><br /></td></tr>
<tr class="separator:ab9b7f9167b3996bf7228daf6c894993b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eaa37a416bdb212f11e63d7540445e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a2eaa37a416bdb212f11e63d7540445e6">normalizeNormalMap</a> (<a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a2eaa37a416bdb212f11e63d7540445e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renormalizes the elements of a signed normal map, replacing <code>(r, g, b)</code> with <code>normalize(r, g, b)</code>.  <a href="structnvtt_1_1_surface.html#a2eaa37a416bdb212f11e63d7540445e6">More...</a><br /></td></tr>
<tr class="separator:a2eaa37a416bdb212f11e63d7540445e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9589b42199086cf7fcb4f99a0bd243d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#aa9589b42199086cf7fcb4f99a0bd243d">transformNormals</a> (<a class="el" href="namespacenvtt.html#a445e3b46e43013ef66771e98f7b1e0ba">NormalTransform</a> xform, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:aa9589b42199086cf7fcb4f99a0bd243d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a 3D-&gt;2D normal transformation, setting the z (blue) channel to 0.  <a href="structnvtt_1_1_surface.html#aa9589b42199086cf7fcb4f99a0bd243d">More...</a><br /></td></tr>
<tr class="separator:aa9589b42199086cf7fcb4f99a0bd243d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad186ad17e1f204e00ecb54e018814cad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#ad186ad17e1f204e00ecb54e018814cad">reconstructNormals</a> (<a class="el" href="namespacenvtt.html#a445e3b46e43013ef66771e98f7b1e0ba">NormalTransform</a> xform, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:ad186ad17e1f204e00ecb54e018814cad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstructs 3D normals from 2D transformed normals.  <a href="structnvtt_1_1_surface.html#ad186ad17e1f204e00ecb54e018814cad">More...</a><br /></td></tr>
<tr class="separator:ad186ad17e1f204e00ecb54e018814cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afedf5e3d9f8b2b7c9f9709690b26013c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#afedf5e3d9f8b2b7c9f9709690b26013c">toCleanNormalMap</a> (<a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:afedf5e3d9f8b2b7c9f9709690b26013c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the z (blue) channel to x^2 + y^2.  <a href="structnvtt_1_1_surface.html#afedf5e3d9f8b2b7c9f9709690b26013c">More...</a><br /></td></tr>
<tr class="separator:afedf5e3d9f8b2b7c9f9709690b26013c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea61a9ee80443c5ad863287499d2e081"><td class="memItemLeft" align="right" valign="top"><a id="aea61a9ee80443c5ad863287499d2e081"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#aea61a9ee80443c5ad863287499d2e081">packNormals</a> (float scale=0.5f, float bias=0.5f, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:aea61a9ee80443c5ad863287499d2e081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packs signed normals in [-1, 1] to an unsigned range [0, 1], using (r, g, b, a) |-&gt; (r/2+1/2, g/2+1/2, b/2+1/2, a). <br /></td></tr>
<tr class="separator:aea61a9ee80443c5ad863287499d2e081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4259f830dd7fb302b2320f2bdc798193"><td class="memItemLeft" align="right" valign="top"><a id="a4259f830dd7fb302b2320f2bdc798193"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a4259f830dd7fb302b2320f2bdc798193">expandNormals</a> (float scale=2.0f, float bias=-1.0f, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a4259f830dd7fb302b2320f2bdc798193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expands packed normals in [0, 1] to signed normals in [-1, 1] using (r, g, b, a) |-&gt; (2r-1, 2g-1, 2b-1, a). <br /></td></tr>
<tr class="separator:a4259f830dd7fb302b2320f2bdc798193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e4ee37e8482f80f13b75241052530f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> <a class="el" href="structnvtt_1_1_surface.html">Surface</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a0e4ee37e8482f80f13b75241052530f2">createToksvigMap</a> (float power, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0) const</td></tr>
<tr class="memdesc:a0e4ee37e8482f80f13b75241052530f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unimplemented. This would equivalent to mipmapping a normal map and then measuring how much mipmapping shortens the normals. Currently returns a null surface.  <a href="structnvtt_1_1_surface.html#a0e4ee37e8482f80f13b75241052530f2">More...</a><br /></td></tr>
<tr class="separator:a0e4ee37e8482f80f13b75241052530f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f9b9c648f52ed64e5b6fe8c7505aa0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> <a class="el" href="structnvtt_1_1_surface.html">Surface</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a4f9b9c648f52ed64e5b6fe8c7505aa0c">createCleanMap</a> (<a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0) const</td></tr>
<tr class="memdesc:a4f9b9c648f52ed64e5b6fe8c7505aa0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unimplemented. Currently returns a null surface.  <a href="structnvtt_1_1_surface.html#a4f9b9c648f52ed64e5b6fe8c7505aa0c">More...</a><br /></td></tr>
<tr class="separator:a4f9b9c648f52ed64e5b6fe8c7505aa0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b4256fa96b9b81e4bc2af448ffaaaf"><td class="memItemLeft" align="right" valign="top"><a id="a23b4256fa96b9b81e4bc2af448ffaaaf"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a23b4256fa96b9b81e4bc2af448ffaaaf">flipX</a> (<a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a23b4256fa96b9b81e4bc2af448ffaaaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flips the surface along the X axis. <br /></td></tr>
<tr class="separator:a23b4256fa96b9b81e4bc2af448ffaaaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e38455acfeb3ca4a8219ed944355a66"><td class="memItemLeft" align="right" valign="top"><a id="a2e38455acfeb3ca4a8219ed944355a66"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a2e38455acfeb3ca4a8219ed944355a66">flipY</a> (<a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a2e38455acfeb3ca4a8219ed944355a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flips the surface along the Y axis. <br /></td></tr>
<tr class="separator:a2e38455acfeb3ca4a8219ed944355a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79d83939e62ac19b2aae843eec0354fa"><td class="memItemLeft" align="right" valign="top"><a id="a79d83939e62ac19b2aae843eec0354fa"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a79d83939e62ac19b2aae843eec0354fa">flipZ</a> (<a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a79d83939e62ac19b2aae843eec0354fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flips the surface along the Z axis. <br /></td></tr>
<tr class="separator:a79d83939e62ac19b2aae843eec0354fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab34e0fad6fff55c86ca7c6546de9e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> <a class="el" href="structnvtt_1_1_surface.html">Surface</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a1ab34e0fad6fff55c86ca7c6546de9e7">createSubImage</a> (int x0, int x1, int y0, int y1, int z0, int z1, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0) const</td></tr>
<tr class="memdesc:a1ab34e0fad6fff55c86ca7c6546de9e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new surface from the range of pixels from x = x0 to x1, y = y0 to y1, and z = z0 to z1.  <a href="structnvtt_1_1_surface.html#a1ab34e0fad6fff55c86ca7c6546de9e7">More...</a><br /></td></tr>
<tr class="separator:a1ab34e0fad6fff55c86ca7c6546de9e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54bb4681e4c3e4e15a2538a05f8a97be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a54bb4681e4c3e4e15a2538a05f8a97be">copyChannel</a> (const <a class="el" href="structnvtt_1_1_surface.html">Surface</a> &amp;srcImage, int srcChannel, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a54bb4681e4c3e4e15a2538a05f8a97be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies channel <code>srcChannel</code> from <code>srcImage</code> to <code>srcChannel</code> of this surface.  <a href="structnvtt_1_1_surface.html#a54bb4681e4c3e4e15a2538a05f8a97be">More...</a><br /></td></tr>
<tr class="separator:a54bb4681e4c3e4e15a2538a05f8a97be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bcfc3fe7fb056860b61607d52cafe50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a7bcfc3fe7fb056860b61607d52cafe50">copyChannel</a> (const <a class="el" href="structnvtt_1_1_surface.html">Surface</a> &amp;srcImage, int srcChannel, int dstChannel, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a7bcfc3fe7fb056860b61607d52cafe50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies channel <code>srcChannel</code> from <code>srcImage</code> to <code>dstChannel</code> of this surface.  <a href="structnvtt_1_1_surface.html#a7bcfc3fe7fb056860b61607d52cafe50">More...</a><br /></td></tr>
<tr class="separator:a7bcfc3fe7fb056860b61607d52cafe50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475066551f1fb973e9dadb21898a19d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a475066551f1fb973e9dadb21898a19d4">addChannel</a> (const <a class="el" href="structnvtt_1_1_surface.html">Surface</a> &amp;img, int srcChannel, int dstChannel, float scale, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a475066551f1fb973e9dadb21898a19d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add channel <code>srcChannel</code> of <code>img</code>, multiplied by <code>scale</code>, to <code>dstChannel</code> of this surface.  <a href="structnvtt_1_1_surface.html#a475066551f1fb973e9dadb21898a19d4">More...</a><br /></td></tr>
<tr class="separator:a475066551f1fb973e9dadb21898a19d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc17efafd545097823b52177b8e4c071"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#afc17efafd545097823b52177b8e4c071">copy</a> (const <a class="el" href="structnvtt_1_1_surface.html">Surface</a> &amp;src, int xsrc, int ysrc, int zsrc, int xsize, int ysize, int zsize, int xdst, int ydst, int zdst, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:afc17efafd545097823b52177b8e4c071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all channels of a rectangle from <code>src</code> to this surface.  <a href="structnvtt_1_1_surface.html#afc17efafd545097823b52177b8e4c071">More...</a><br /></td></tr>
<tr class="separator:afc17efafd545097823b52177b8e4c071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba4b4cc0b224540af8172c96080d1104"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#aba4b4cc0b224540af8172c96080d1104">ToGPU</a> (<a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0, bool performCopy=true)</td></tr>
<tr class="memdesc:aba4b4cc0b224540af8172c96080d1104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes succeeding operations work on the GPU buffer.  <a href="structnvtt_1_1_surface.html#aba4b4cc0b224540af8172c96080d1104">More...</a><br /></td></tr>
<tr class="separator:aba4b4cc0b224540af8172c96080d1104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d2adde550afe049b5fb0f726ad41c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a58d2adde550afe049b5fb0f726ad41c5">ToCPU</a> (<a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a58d2adde550afe049b5fb0f726ad41c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes succeeding operations work on the CPU buffer.  <a href="structnvtt_1_1_surface.html#a58d2adde550afe049b5fb0f726ad41c5">More...</a><br /></td></tr>
<tr class="separator:a58d2adde550afe049b5fb0f726ad41c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefedacd34e62dad9a3908a4bbdbf9ed3"><td class="memItemLeft" align="right" valign="top"><a id="aefedacd34e62dad9a3908a4bbdbf9ed3"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> const float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#aefedacd34e62dad9a3908a4bbdbf9ed3">gpuData</a> () const</td></tr>
<tr class="memdesc:aefedacd34e62dad9a3908a4bbdbf9ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a CUDA pointer to const image data on the GPU, using the same layout as <a class="el" href="structnvtt_1_1_surface.html#a09a9830d99707456c59a9b0658a33f5f" title="Returns a pointer that can be used to modify the surface&#39;s CPU data. See data() const.">data()</a>. If GPU data does not exist, returns <code>nullptr</code>. <br /></td></tr>
<tr class="separator:aefedacd34e62dad9a3908a4bbdbf9ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db5f7842604659edf5759cb7e07c3ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html#a9db5f7842604659edf5759cb7e07c3ad">gpuDataMutable</a> ()</td></tr>
<tr class="memdesc:a9db5f7842604659edf5759cb7e07c3ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a CUDA pointer to non-const image data on the GPU, using the same layout as <a class="el" href="structnvtt_1_1_surface.html#a09a9830d99707456c59a9b0658a33f5f" title="Returns a pointer that can be used to modify the surface&#39;s CPU data. See data() const.">data()</a>. If GPU data does not exist, returns <code>nullptr</code>. This can be used to modify NVTT <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">Surface</a> data on the GPU, outside of the functions NVTT provides.  <a href="structnvtt_1_1_surface.html#a9db5f7842604659edf5759cb7e07c3ad">More...</a><br /></td></tr>
<tr class="separator:a9db5f7842604659edf5759cb7e07c3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36bc72c66197721297d1a47a4de1b1b8"><td class="memItemLeft" align="right" valign="top"><a id="a36bc72c66197721297d1a47a4de1b1b8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>detach</b> ()</td></tr>
<tr class="separator:a36bc72c66197721297d1a47a4de1b1b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a7c44bc9884c2beb1058825a4afae765d"><td class="memItemLeft" align="right" valign="top"><a id="a7c44bc9884c2beb1058825a4afae765d"></a>
Private *&#160;</td><td class="memItemRight" valign="bottom"><b>m</b></td></tr>
<tr class="separator:a7c44bc9884c2beb1058825a4afae765d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A surface is one level of a 2D or 3D texture. </p>
<p>A surface has four channels numbered 0-3, also referred to as the red, green, blue, and alpha channels.</p>
<p>Surfaces store some additional properties, such as their width, height, depth, wrap mode, alpha mode, and whether they represent a normal map.</p>
<p>Surfaces can have CPU and GPU data. If a surface has GPU data, it always has CPU data. When the surface is GPU-enabled (using <a class="el" href="structnvtt_1_1_surface.html#aba4b4cc0b224540af8172c96080d1104" title="Makes succeeding operations work on the GPU buffer.">ToGPU()</a>), image processing will be CUDA-accelerated and work on this GPU data. Calling <a class="el" href="structnvtt_1_1_surface.html#a58d2adde550afe049b5fb0f726ad41c5" title="Makes succeeding operations work on the CPU buffer.">ToCPU()</a> will copy the GPU data to the CPU and destroy the GPU data buffer. <code><a class="el" href="structnvtt_1_1_surface.html#aefedacd34e62dad9a3908a4bbdbf9ed3" title="Get a CUDA pointer to const image data on the GPU, using the same layout as data()....">gpuData()</a> != nullptr</code> can be used to determine if a surface has GPU data.</p>
<p>To directly access CPU data, use <a class="el" href="structnvtt_1_1_surface.html#a09a9830d99707456c59a9b0658a33f5f" title="Returns a pointer that can be used to modify the surface&#39;s CPU data. See data() const.">data()</a> or <a class="el" href="structnvtt_1_1_surface.html#ab730fd435ee2f51defc87ef9aa749748" title="Returns a const pointer to channel i&#39;s CPU data.">channel()</a>. To get a pointer to the GPU data buffer, use <a class="el" href="structnvtt_1_1_surface.html#aefedacd34e62dad9a3908a4bbdbf9ed3" title="Get a CUDA pointer to const image data on the GPU, using the same layout as data()....">gpuData()</a> (for a const CUDA pointer) or <a class="el" href="structnvtt_1_1_surface.html#a9db5f7842604659edf5759cb7e07c3ad" title="Get a CUDA pointer to non-const image data on the GPU, using the same layout as data()....">gpuDataMutable()</a> (for a CUDA pointer to modifiable data).</p>
<p>Texture data is stored non-interleaved; that is, all channel 0's data is stored first, followed by channel 1's, and so on.</p>
<dl class="section note"><dt>Note</dt><dd>Performance note: Surfaces use reference-counted pointers to image data. This means that multiple Surfaces can reference the same data. This is handled automatically by NVTT's image processing routines. For instance, after the following piece of code, <div class="fragment"><div class="line"><a class="code" href="structnvtt_1_1_surface.html">nvtt::Surface</a> s1;</div>
<div class="line">s1.<a class="code" href="structnvtt_1_1_surface.html#a5a47935fcb94952c439aa5a4e4d4f498">setImage</a>(...);</div>
<div class="line"><a class="code" href="structnvtt_1_1_surface.html">nvtt::Surface</a> s2 = s1;</div>
<div class="ttc" id="astructnvtt_1_1_surface_html"><div class="ttname"><a href="structnvtt_1_1_surface.html">nvtt::Surface</a></div><div class="ttdoc">A surface is one level of a 2D or 3D texture.</div><div class="ttdef"><b>Definition:</b> nvtt.h:674</div></div>
<div class="ttc" id="astructnvtt_1_1_surface_html_a5a47935fcb94952c439aa5a4e4d4f498"><div class="ttname"><a href="structnvtt_1_1_surface.html#a5a47935fcb94952c439aa5a4e4d4f498">nvtt::Surface::setImage</a></div><div class="ttdeci">NVTT_API bool setImage(int w, int h, int d, TimingContext *tc=0)</div><div class="ttdoc">Sets this surface to a new w x h x d uninitialized image.</div></div>
</div><!-- fragment --> surfaces <code>s1</code> and <code>s2</code> will have the same <code><a class="el" href="structnvtt_1_1_surface.html#a09a9830d99707456c59a9b0658a33f5f" title="Returns a pointer that can be used to modify the surface&#39;s CPU data. See data() const.">data()</a></code> pointer. Cloning the underlying data is handled automatically: for instance, after <div class="fragment"><div class="line">s2.<a class="code" href="structnvtt_1_1_surface.html#a17627047b1633a02c1d78e8de403bb6a">toSrgb</a>()</div>
<div class="ttc" id="astructnvtt_1_1_surface_html_a17627047b1633a02c1d78e8de403bb6a"><div class="ttname"><a href="structnvtt_1_1_surface.html#a17627047b1633a02c1d78e8de403bb6a">nvtt::Surface::toSrgb</a></div><div class="ttdeci">NVTT_API void toSrgb(TimingContext *tc=0)</div><div class="ttdoc">Applies the linear-to-sRGB transfer function to channels 0...2.</div></div>
</div><!-- fragment --> <code>s2</code> will have a new <code><a class="el" href="structnvtt_1_1_surface.html#a09a9830d99707456c59a9b0658a33f5f" title="Returns a pointer that can be used to modify the surface&#39;s CPU data. See data() const.">data()</a></code> pointer, and <code>s1</code> will be unchanged. This usually means that when writing custom image processing routines, you'll want to call <a class="el" href="structnvtt_1_1_surface.html#a7715f4c5b9c06016055877dd31a39c99" title="Creates a deep copy of this Surface, with its own internal data. (New in NVTT 3.1)">Surface::clone()</a> before modifying the <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">Surface</a>'s data. Using Nsight Systems is one way to detect when additional allocations occur.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>NVTT 2.1 </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a475066551f1fb973e9dadb21898a19d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a475066551f1fb973e9dadb21898a19d4">&#9670;&nbsp;</a></span>addChannel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool nvtt::Surface::addChannel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_surface.html">Surface</a> &amp;&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dstChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add channel <code>srcChannel</code> of <code>img</code>, multiplied by <code>scale</code>, to <code>dstChannel</code> of this surface. </p>
<p>Returns whether the operation succeeded (for instance, it can fail if the surfaces have different sizes).</p>
<p>Both <code>srcChannel</code> and <code>dstChannel</code> must be in the range [0, 3].</p>
<p>The surfaces need not have the same GPU mode. </p>

</div>
</div>
<a id="a3b4cdb2773ea35b42ea460a2b4026cbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b4cdb2773ea35b42ea460a2b4026cbe">&#9670;&nbsp;</a></span>alphaTestCoverage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> float nvtt::Surface::alphaTestCoverage </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>alphaRef</em> = <code>0.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>alpha_channel</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the approximate fraction (0 to 1) of the image with an alpha value greater than <code>alphaRef</code>. </p>
<p>This function uses 8 x 8 subsampling together with linear interpolation.</p>
<dl class="section note"><dt>Note</dt><dd><code>alphaRef</code> is clamped to the range [1/256, 255/256]. </dd></dl>

</div>
</div>
<a id="ae9ed55dcc5f3f3d297e02872164be2d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9ed55dcc5f3f3d297e02872164be2d5">&#9670;&nbsp;</a></span>average()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> float nvtt::Surface::average </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>alpha_channel</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>gamma</em> = <code>2.2f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the average of a channel, possibly with alpha or with a gamma transfer function. </p>
<p>If <code>alpha_channel</code> is -1, this function computes</p>
<p><code>(sum(c[i]^gamma, i=0...numPixels)/numPixels)^(1/gamma)</code></p>
<p>where <code>c</code> is the channel's data.</p>
<p>Otherwise, this computes</p>
<p><code>(sum((c[i]^gamma) * a[i], i=0...numPixels)/sum(a[i], i=0...numPixels))^(1/gamma)</code></p>
<p>where <code>a</code> is the alpha channel's data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The channel to average. </td></tr>
    <tr><td class="paramname">alpha_channel</td><td>If not equal to -1, weights each texel's value after gamma correction by this channel. </td></tr>
    <tr><td class="paramname">gamma</td><td>Gamma for the transfer function to apply. A value of 2.2f roughly corresponds to averaging an sRGB image in linear space, then converting back to sRGB. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a0f61ae151ef04bd250d57f8987b592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a0f61ae151ef04bd250d57f8987b592">&#9670;&nbsp;</a></span>binarize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::binarize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dither</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets values in the given channel to either 1 or 0 depending on if they're greater than the threshold, with optional dithering. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dither</td><td>If true, uses Floyd-Steinberg dithering on the CPU. Not supported for 3D surfaces. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d369d23a1d438f49f120515d6343952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d369d23a1d438f49f120515d6343952">&#9670;&nbsp;</a></span>blend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::blend </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolates all texels between their current color and a constant color <code>(r, g, b, a)</code>. </p>
<p><code>t</code> is the value used for linearly interpolating between the surface's current colors and the constant color. For instance, a value of <code>t=0</code> has no effect to the surface's colors, and a value of <code>t=1</code> replaces the surface's colors entirely with (r, g, b, a). </p>

</div>
</div>
<a id="afccc1a72d64b4c92fa98f746c700704e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afccc1a72d64b4c92fa98f746c700704e">&#9670;&nbsp;</a></span>blockScaleCoCg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::blockScaleCoCg </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bits</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>0.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores per-block YCoCg scaling information for potentially better 4-channel compression of YCoCg data. </p>
<p>For each 4x4 block, this computes the maximum absolute Co and Cg values, stores the result in the blue channel, and multiplies the Co and Cg channels (0 and 1) by its reciprocal. The original Co and Cg values can then be reconstructed by multiplying by the blue channel.</p>
<p>The scaling information is quantized to the given number of bits.</p>
<p><code>threshold</code> is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This assumes that your texture compression format uses 4x4 blocks. This is true for all BC1-BC7 formats, but ASTC can use other block sizes. </dd></dl>

</div>
</div>
<a id="afbedd7b081d94ca7641d33453c3b96ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbedd7b081d94ca7641d33453c3b96ed">&#9670;&nbsp;</a></span>buildNextMipmap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool nvtt::Surface::buildNextMipmap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenvtt.html#a28d4701da3f4e6935956949dab69c479">MipmapFilter</a>&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>filterWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>params</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min_size</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Version of <a class="el" href="structnvtt_1_1_surface.html#ab85e9ae8132a60fcf923300687af2778" title="Resizes this surface to create the next mip in a mipmap chain.">buildNextMipmap(MipmapFilter, int, TimingContext*)</a> with customizable parameters. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacenvtt.html#a28d4701da3f4e6935956949dab69c479" title="Mipmap downsampling filters. Each of these can be customized using filterWidth and params when callin...">MipmapFilter</a> for the effects of different parameters. </dd></dl>

</div>
</div>
<a id="ab85e9ae8132a60fcf923300687af2778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab85e9ae8132a60fcf923300687af2778">&#9670;&nbsp;</a></span>buildNextMipmap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool nvtt::Surface::buildNextMipmap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenvtt.html#a28d4701da3f4e6935956949dab69c479">MipmapFilter</a>&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min_size</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes this surface to create the next mip in a mipmap chain. </p>
<p>Returns false iff the next mip would have been smaller than <code>min_size</code> (signaling the end of the mipmap chain). </p>

</div>
</div>
<a id="a4d48d0db77b102facf116ceb2d751371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d48d0db77b102facf116ceb2d751371">&#9670;&nbsp;</a></span>buildNextMipmapSolidColor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool nvtt::Surface::buildNextMipmapSolidColor </td>
          <td>(</td>
          <td class="paramtype">const float *const&#160;</td>
          <td class="paramname"><em>color_components</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces this surface with a surface the size of the next mip in a mip chain (half the width and height), but with each channel cleared to a constant value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color_components</td><td>is an array of the value for each channel; it must be at least as long as the number of channels in the surface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af3e981006d2b89d085f94f592d11d876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3e981006d2b89d085f94f592d11d876">&#9670;&nbsp;</a></span>canMakeNextMipmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool nvtt::Surface::canMakeNextMipmap </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min_size</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether a the surface would have a next mip in a mip chain with minimum size `min_size. </p>
<p>That is, it returns false if this surface has size 1x1x1, or if the width and height are less than <code>min_size</code> and the depth is 1. </p>

</div>
</div>
<a id="ab730fd435ee2f51defc87ef9aa749748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab730fd435ee2f51defc87ef9aa749748">&#9670;&nbsp;</a></span>channel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> const float* nvtt::Surface::channel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <code>const</code> pointer to channel i's CPU data. </p>
<p>Data is stored in [z, y, x] order; that is, all channel 0's data comes first, followed by all channel 1's data, and so on. More specifically, the value of channel c of the texel at (x, y, z) is at index</p>
<p><code>(z * <a class="el" href="structnvtt_1_1_surface.html#a059d6eadb470e5b4209ad12e7c73309e" title="Returns the height (Y size) of the surface.">height()</a> + y) * <a class="el" href="structnvtt_1_1_surface.html#ab766483595f4db56c7807bf0c81ed98c" title="Returns the width (X size) of the surface.">width()</a> + x</code></p>
<p>of channel(c).</p>
<dl class="section note"><dt>Note</dt><dd>If the image has GPU data (see <a class="el" href="structnvtt_1_1_surface.html#aba4b4cc0b224540af8172c96080d1104" title="Makes succeeding operations work on the GPU buffer.">ToGPU()</a>), this performs a GPU-to-CPU copy. </dd></dl>

</div>
</div>
<a id="a2db053835be6f1060c414e46d34385db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2db053835be6f1060c414e46d34385db">&#9670;&nbsp;</a></span>convolve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::convolve </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kernelSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>kernelData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convolves a channel with a kernel. </p>
<p>This uses a 2D kernelSize x kernelSize kernel, with values in <code>kernelData</code> specified in row-major order. The behavior around image borders is determined by the image's wrap mode. </p>

</div>
</div>
<a id="afc17efafd545097823b52177b8e4c071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc17efafd545097823b52177b8e4c071">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool nvtt::Surface::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_surface.html">Surface</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xsrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ysrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zsrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ysize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xdst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ydst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zdst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies all channels of a rectangle from <code>src</code> to this surface. </p>
<p>More specifically, this copies the rectangle</p>
<p><code>[xsrc, xsrc + xsize - 1] x [ysrc, ysrc + ysize - 1] x [zsrc, zsrc + zsize - 1]</code></p>
<p>to the rectangle</p>
<p><code>[xdst, xdst + xsize - 1] x [ydst, ydst + ysize - 1] x [zdst, zdst + zsize - 1]</code>.</p>
<p>Returns whether the operation succeeded (for instance, invalid parameters return false). </p>

</div>
</div>
<a id="a7bcfc3fe7fb056860b61607d52cafe50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bcfc3fe7fb056860b61607d52cafe50">&#9670;&nbsp;</a></span>copyChannel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool nvtt::Surface::copyChannel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_surface.html">Surface</a> &amp;&#160;</td>
          <td class="paramname"><em>srcImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dstChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies channel <code>srcChannel</code> from <code>srcImage</code> to <code>dstChannel</code> of this surface. </p>
<p>Returns whether the operation succeeded (for instance, it can fail if the surfaces have different sizes).</p>
<p>Both <code>srcChannel</code> and <code>dstChannel</code> must be in the range [0, 3].</p>
<p>The surfaces need not have the same GPU mode. </p>

</div>
</div>
<a id="a54bb4681e4c3e4e15a2538a05f8a97be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54bb4681e4c3e4e15a2538a05f8a97be">&#9670;&nbsp;</a></span>copyChannel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool nvtt::Surface::copyChannel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_surface.html">Surface</a> &amp;&#160;</td>
          <td class="paramname"><em>srcImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies channel <code>srcChannel</code> from <code>srcImage</code> to <code>srcChannel</code> of this surface. </p>
<p>Returns whether the operation succeeded (for instance, it can fail if the surfaces have different sizes).</p>
<p><code>srcChannel</code> must be in the range [0, 3].</p>
<p>The surfaces need not have the same GPU mode. </p>

</div>
</div>
<a id="a9d4de8d67b1fb1ac8a96ff1af239b436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d4de8d67b1fb1ac8a96ff1af239b436">&#9670;&nbsp;</a></span>countMipmaps() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> int nvtt::Surface::countMipmaps </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of mipmaps in a full mipmap chain. Each mip is half the size of the previous, rounding down, until and including a 1x1 mip. </p>
<p>For instance, a 8x5 surface has mipmaps of size 8x5 (mip 0), 4x2 (mip 1), 2x1 (mip 2), and 1x1 (mip 3), so <a class="el" href="structnvtt_1_1_surface.html#a9d4de8d67b1fb1ac8a96ff1af239b436" title="Returns the number of mipmaps in a full mipmap chain. Each mip is half the size of the previous,...">countMipmaps()</a> returns 4. A 7x3 surface has mipmaps of size 7x3, 3x1, and 1x1, so <a class="el" href="structnvtt_1_1_surface.html#a9d4de8d67b1fb1ac8a96ff1af239b436" title="Returns the number of mipmaps in a full mipmap chain. Each mip is half the size of the previous,...">countMipmaps()</a> returns 3. </p>

</div>
</div>
<a id="a85f3fd4ea1fd7e31dcfc1d6a6f81ad4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f3fd4ea1fd7e31dcfc1d6a6f81ad4a">&#9670;&nbsp;</a></span>countMipmaps() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> int nvtt::Surface::countMipmaps </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min_size</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of mipmaps in a mipmap chain, stopping when <a class="el" href="structnvtt_1_1_surface.html#af3e981006d2b89d085f94f592d11d876" title="Returns whether a the surface would have a next mip in a mip chain with minimum size `min_size.">canMakeNextMipmap()</a> returns false. </p>
<p>That is, it stops when a 1x1x1 mip is reached if <code>min_size == 1</code> (in which case it is the same as <a class="el" href="structnvtt_1_1_surface.html#a9d4de8d67b1fb1ac8a96ff1af239b436" title="Returns the number of mipmaps in a full mipmap chain. Each mip is half the size of the previous,...">countMipmaps()</a>), or stops when the width and height are less than <code>min_size</code> and the depth is 1.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structnvtt_1_1_surface.html#af3e981006d2b89d085f94f592d11d876" title="Returns whether a the surface would have a next mip in a mip chain with minimum size `min_size.">canMakeNextMipmap()</a>. </dd></dl>

</div>
</div>
<a id="a4f9b9c648f52ed64e5b6fe8c7505aa0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f9b9c648f52ed64e5b6fe8c7505aa0c">&#9670;&nbsp;</a></span>createCleanMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> <a class="el" href="structnvtt_1_1_surface.html">Surface</a> nvtt::Surface::createCleanMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unimplemented. Currently returns a null surface. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structnvtt_1_1_surface.html#afedf5e3d9f8b2b7c9f9709690b26013c" title="Sets the z (blue) channel to x^2 + y^2.">toCleanNormalMap()</a> </dd></dl>

</div>
</div>
<a id="a1ab34e0fad6fff55c86ca7c6546de9e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab34e0fad6fff55c86ca7c6546de9e7">&#9670;&nbsp;</a></span>createSubImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> <a class="el" href="structnvtt_1_1_surface.html">Surface</a> nvtt::Surface::createSubImage </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>z0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>z1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new surface from the range of pixels from x = x0 to x1, y = y0 to y1, and z = z0 to z1. </p>
<p>If any of the parameters are out of bounds or creation fails, returns a null surface.</p>
<p>A valid surface created will have size (x1 - x0 + 1) x (y1 - y0 + 1) x (z1 - z0 + 1). </p>

</div>
</div>
<a id="a0e4ee37e8482f80f13b75241052530f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e4ee37e8482f80f13b75241052530f2">&#9670;&nbsp;</a></span>createToksvigMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> <a class="el" href="structnvtt_1_1_surface.html">Surface</a> nvtt::Surface::createToksvigMap </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>power</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unimplemented. This would equivalent to mipmapping a normal map and then measuring how much mipmapping shortens the normals. Currently returns a null surface. </p>
<dl class="section see"><dt>See also</dt><dd>Hill, "Specular Showdown in the Wild West", <a href="http://blog.selfshadow.com/2011/07/22/specular-showdown/">http://blog.selfshadow.com/2011/07/22/specular-showdown/</a> </dd></dl>

</div>
</div>
<a id="a7d00fffaca7a69457c4db0a8af28fcd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d00fffaca7a69457c4db0a8af28fcd2">&#9670;&nbsp;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> const float* nvtt::Surface::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <code>const</code> pointer to the surface's CPU data. </p>
<p>Data is stored in [c, z, y, x] order; that is, all channel 0's data comes first, followed by all channel 1's data, and so on. More specifically, the value of channel c of the texel at (x, y, z) is at index</p>
<p><code>((c * <a class="el" href="structnvtt_1_1_surface.html#a6ceabda2b08248eecbe991b708ae52fb" title="Returns the depth (Z size) of the surface. 1 for 2D surfaces.">depth()</a> + z) * <a class="el" href="structnvtt_1_1_surface.html#a059d6eadb470e5b4209ad12e7c73309e" title="Returns the height (Y size) of the surface.">height()</a> + y) * <a class="el" href="structnvtt_1_1_surface.html#ab766483595f4db56c7807bf0c81ed98c" title="Returns the width (X size) of the surface.">width()</a> + x</code>.</p>
<dl class="section note"><dt>Note</dt><dd>If the image has GPU data (see <a class="el" href="structnvtt_1_1_surface.html#aba4b4cc0b224540af8172c96080d1104" title="Makes succeeding operations work on the GPU buffer.">ToGPU()</a>), this performs a GPU-to-CPU copy. </dd></dl>

</div>
</div>
<a id="a907f237e7825d33836d253f21fca2274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a907f237e7825d33836d253f21fca2274">&#9670;&nbsp;</a></span>demultiplyAlpha()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::demultiplyAlpha </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>1e-12f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts from premultiplied to unpremultiplied alpha, with special handling around zero alpha values. </p>
<p>When <code>abs(a) &gt;= epsilon</code>, the result is the same as dividing the RGB channels by the alpha channel. Otherwise, this function divides the RGB channels by <code>epsilon * sign(a)</code>, since the result of unpremultiplying a fully transparent color is undefined. </p>

</div>
</div>
<a id="a44e3a7cbb1ab51b47ba7897563de5323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44e3a7cbb1ab51b47ba7897563de5323">&#9670;&nbsp;</a></span>fromLUVW()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::fromLUVW </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>range</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts from <a class="el" href="structnvtt_1_1_surface.html#ab042fa04f955079c069a5161ed2c3135" title="Converts from RGB colors to a (U, V, W, L) color space, much like RGBM.">toLUVW()</a>'s color space to RGB colors. </p>
<p>This is the same as fromRGBM(range * sqrt(3)). </p>

</div>
</div>
<a id="ac739fbfff5eb5237ca7d3635477681cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac739fbfff5eb5237ca7d3635477681cc">&#9670;&nbsp;</a></span>fromRGBE()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::fromRGBE </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mantissaBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>exponentBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Produces HDR <code>(r, g, b, 1)</code> values from an LDR <code>(red, green, blue, exponent)</code> storage method. </p>
<p>HDR values are reconstructed as follows: R, G, B, and E are first converted from UNORM floats to integers by multiplying RGB by <code>(1 &lt;&lt; mantissaBits) - 1</code> and E by <code>(1 &lt;&lt; exponentBits) - 1</code>. E stores a scaling factor as a power of 2, which is reconstructed using <code>scale = 2^(E - ((1 &lt;&lt; (exponentBits - 1)) - 1) - mantissaBits)</code>. R, G, and B are then multiplied by <code>scale</code>.</p>
<p><code>mantissaBits</code> and <code>exponentBits</code> must be in the range 1...31. </p>

</div>
</div>
<a id="a37ee98276a237caf39437f5aa64730e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37ee98276a237caf39437f5aa64730e0">&#9670;&nbsp;</a></span>fromRGBM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::fromRGBM </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>range</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>0.25f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Produces HDR <code>(r, g, b, 1)</code> values from an LDR <code>(red, green, blue, magnitude)</code> storage method. </p>
<p>HDR values are reconstructed as follows: First, the magnitude <code>M</code> is reconstructed from the alpha channel using <code>M = a * (range - threshold) + threshold</code>. Then the red, green, and blue channels are multiplied by <code>M</code>. </p>

</div>
</div>
<a id="a04bb71ed43deb8454491d554ac2e3145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04bb71ed43deb8454491d554ac2e3145">&#9670;&nbsp;</a></span>fromYCoCg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::fromYCoCg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts from <code>(Co, Cg, scale, Y)</code> colors to <code>(r, g, b, 1)</code> colors. </p>
<p>This is useful for formats that use chroma subsampling.</p>
<p>Y is in the range [0, 1], while Co and Cg are in the range [-1, 1]. Co and Cg are multiplied by channel 2 (scale) to reverse the effects of optionally calling <a class="el" href="structnvtt_1_1_surface.html#afccc1a72d64b4c92fa98f746c700704e" title="Stores per-block YCoCg scaling information for potentially better 4-channel compression of YCoCg data...">blockScaleCoCg()</a>.</p>
<p>The YCoCg-to-RGB formula used is </p><div class="fragment"><div class="line">r = Y + Co - Cg</div>
<div class="line">g = Y + Cg</div>
<div class="line">b = Y - Co - Cg</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a9db5f7842604659edf5759cb7e07c3ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9db5f7842604659edf5759cb7e07c3ad">&#9670;&nbsp;</a></span>gpuDataMutable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> float* nvtt::Surface::gpuDataMutable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a CUDA pointer to non-const image data on the GPU, using the same layout as <a class="el" href="structnvtt_1_1_surface.html#a09a9830d99707456c59a9b0658a33f5f" title="Returns a pointer that can be used to modify the surface&#39;s CPU data. See data() const.">data()</a>. If GPU data does not exist, returns <code>nullptr</code>. This can be used to modify NVTT <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">Surface</a> data on the GPU, outside of the functions NVTT provides. </p>
<dl class="section since"><dt>Since</dt><dd>NVTT 3.2 </dd></dl>

</div>
</div>
<a id="a315247163465480bfc38c9a63a4f4e3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a315247163465480bfc38c9a63a4f4e3a">&#9670;&nbsp;</a></span>histogram()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::histogram </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rangeMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rangeMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>binCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>binPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores a histogram of channel values between <code>rangeMin</code> and <code>rangeMax</code> into <code>binPtr[0...binCount-1]</code>. </p>
<p><code>binPtr</code> must be an array of at least <code>binCount</code> integers. This function does not clear <code>binPtr</code>'s values, in case we want to accumulate multiple histograms.</p>
<p>Each texel's value is linearly mapped to a bin, using floor rounding. Values below <code>rangeMin</code> are clamped to bin 0, values above <code>rangeMax</code> are clamped to bin <code>binCount-1</code>. Then the bin's value is incremented. </p>

</div>
</div>
<a id="a7162b072976c0134a3854df107c2b7d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7162b072976c0134a3854df107c2b7d5">&#9670;&nbsp;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool nvtt::Surface::load </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>hasAlpha</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>expectSigned</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads texture data from a file. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if loading succeeded and <code>false</code> if it failed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>Path to the file to load. This uses the same character encoding as the <code>filename</code> argument of <code>fopen()</code>. </td></tr>
    <tr><td class="paramname">hasAlpha</td><td>If this is non-null, then <code>*hasAlpha</code> will be set to whether the reader reported that the file included an alpha channel. </td></tr>
    <tr><td class="paramname">expectSigned</td><td>If this is true, then some forms of unsigned data will be converted to signed using the mapping x |-&gt; 2x-1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a779543e6e00e503a8734b1281ff25b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a779543e6e00e503a8734b1281ff25b5b">&#9670;&nbsp;</a></span>loadFromMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool nvtt::Surface::loadFromMemory </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>sizeInBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>hasAlpha</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>expectSigned</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variant of <a class="el" href="structnvtt_1_1_surface.html#a7162b072976c0134a3854df107c2b7d5" title="Loads texture data from a file.">load()</a> that reads from memory instead of a file. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if loading succeeded and <code>false</code> if it failed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to the start of the file's data in memory. </td></tr>
    <tr><td class="paramname">sizeInBytes</td><td>Length of the file's data. </td></tr>
    <tr><td class="paramname">hasAlpha</td><td>If this is non-null, then <code>*hasAlpha</code> will be set to whether the reader reported that the file included an alpha channel. </td></tr>
    <tr><td class="paramname">expectSigned</td><td>If this is true, then some forms of unsigned data will be converted to signed using the mapping x |-&gt; 2x-1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2eaa37a416bdb212f11e63d7540445e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eaa37a416bdb212f11e63d7540445e6">&#9670;&nbsp;</a></span>normalizeNormalMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::normalizeNormalMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renormalizes the elements of a signed normal map, replacing <code>(r, g, b)</code> with <code>normalize(r, g, b)</code>. </p>
<p>This function is safe to call even for zero vectors. </p>

</div>
</div>
<a id="ad4fd978431757e6b3f4c1e6e114ffc40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4fd978431757e6b3f4c1e6e114ffc40">&#9670;&nbsp;</a></span>quantize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::quantize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exactEndPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dither</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Quantizes this channel to a particular number of bits, with optional dithering. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The index of the channel to quantize. </td></tr>
    <tr><td class="paramname">bits</td><td>The number of bits to quantize to, yielding <code>2^bits</code> possible values. Must be nonnegative, and must not be 0 if exactEndPoints is true. </td></tr>
    <tr><td class="paramname">exactEndPoints</td><td>If true, the set of quantized values will be <code>0, 1/(2^bits-1), ..., 1</code>, rather than <code>0, 1/(2^bits), ..., (2^bits-1)/(2^bits)</code>. </td></tr>
    <tr><td class="paramname">dither</td><td>If true, uses Floyd-Steinberg dithering on the CPU. Not supported for 3D surfaces. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc8a14675ef0cbc891bfe839d29a1c29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc8a14675ef0cbc891bfe839d29a1c29">&#9670;&nbsp;</a></span>range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::range </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>rangeMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>rangeMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>alpha_channel</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>alpha_ref</em> = <code>0.f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets <code>*rangeMin</code> and <code>*rangeMax</code> to the range of values in the channel, possibly using alpha testing. </p>
<p>If <code>alpha_channel</code> is -1, this sets <code>*rangeMin</code> to the smallest value in the entire channel, and <code>*rangeMax</code> to the largest value in the entire channel. Otherwise, this only includes texels for which the alpha value is greater than <code>alpha_ref</code>.</p>
<p>If the image is null or if an alpha channel is selected and all texels fail the alpha test, this sets <code>*rangeMin</code> to <code>FLT_MAX</code> and <code>*rangeMax</code> to <code>FLT_MIN</code>, i.e. one will have <code>*rangeMin &gt; *rangeMax</code>. </p>

</div>
</div>
<a id="ad186ad17e1f204e00ecb54e018814cad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad186ad17e1f204e00ecb54e018814cad">&#9670;&nbsp;</a></span>reconstructNormals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::reconstructNormals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenvtt.html#a445e3b46e43013ef66771e98f7b1e0ba">NormalTransform</a>&#160;</td>
          <td class="paramname"><em>xform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reconstructs 3D normals from 2D transformed normals. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacenvtt.html#a445e3b46e43013ef66771e98f7b1e0ba" title="Specifies a normal transformation, used to store 3D (x, y, z) normals in 2D (x, y).">NormalTransform</a> for definitions of each of the normal transformations. </dd></dl>

</div>
</div>
<a id="a6f66cd503c0b7fd8667cfc7acca170e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f66cd503c0b7fd8667cfc7acca170e4">&#9670;&nbsp;</a></span>resize() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::resize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxExtent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenvtt.html#a673a22796ec42ae50e14ab1ed6906bd5">RoundMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenvtt.html#a3607100ce561fdaa3859abd0f05878c7">ResizeFilter</a>&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>filterWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>params</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes this surface so that its largest side has length <code>maxExtent</code>, subject to a rounding mode, using customizable filter parameters. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacenvtt.html#a73aebd76a0eef81407c40b5b93ee7c10" title="Geting the target extent for round-mode and texture-type. (New in NVTT 3.0)">getTargetExtent()</a> </dd></dl>

</div>
</div>
<a id="ac459aa4c41f41ec0f615b6352e3262c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac459aa4c41f41ec0f615b6352e3262c2">&#9670;&nbsp;</a></span>resize() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::resize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxExtent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenvtt.html#a673a22796ec42ae50e14ab1ed6906bd5">RoundMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenvtt.html#a3607100ce561fdaa3859abd0f05878c7">ResizeFilter</a>&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes this surface so that its largest side has length <code>maxExtent</code>, subject to a rounding mode. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacenvtt.html#a73aebd76a0eef81407c40b5b93ee7c10" title="Geting the target extent for round-mode and texture-type. (New in NVTT 3.0)">getTargetExtent()</a> </dd></dl>

</div>
</div>
<a id="a013d651c695516e8fdbdf7634573918a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a013d651c695516e8fdbdf7634573918a">&#9670;&nbsp;</a></span>resize() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::resize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenvtt.html#a3607100ce561fdaa3859abd0f05878c7">ResizeFilter</a>&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>filterWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>params</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resizes this surface using customizable filter parameters.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacenvtt.html#a3607100ce561fdaa3859abd0f05878c7" title="Texture resizing filters.">ResizeFilter</a> for filter-specific parameters. </dd></dl>

</div>
</div>
<a id="af84c67783861084298893fa54f031624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af84c67783861084298893fa54f031624">&#9670;&nbsp;</a></span>resize_make_square()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::resize_make_square </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxExtent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenvtt.html#a673a22796ec42ae50e14ab1ed6906bd5">RoundMode</a>&#160;</td>
          <td class="paramname"><em>roundMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenvtt.html#a3607100ce561fdaa3859abd0f05878c7">ResizeFilter</a>&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes this surface so that its longest side has length <code>maxExtent</code> and the result is square or cubical. </p>
<p>For 2D surfaces, the size is determined using <a class="el" href="namespacenvtt.html#a73aebd76a0eef81407c40b5b93ee7c10" title="Geting the target extent for round-mode and texture-type. (New in NVTT 3.0)">getTargetExtent()</a>, then using the minimum of the width and height. For 3D surfaces, the size is similarly determined using <a class="el" href="namespacenvtt.html#a73aebd76a0eef81407c40b5b93ee7c10" title="Geting the target extent for round-mode and texture-type. (New in NVTT 3.0)">getTargetExtent()</a>, then using the minimum of the width, height, or depth. </p>

</div>
</div>
<a id="a103d5b57c7153ceb77f23a3d9714c706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a103d5b57c7153ceb77f23a3d9714c706">&#9670;&nbsp;</a></span>save()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool nvtt::Surface::save </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>hasAlpha</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>hdr</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves texture data to file. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if saving succeeded and <code>false</code> if it failed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>Path to the file to load. This uses the same character encoding as the <code>filename</code> argument of <code>fopen()</code>. </td></tr>
    <tr><td class="paramname">hasAlpha</td><td>If true, then TGA images will be saved with an alpha channel. </td></tr>
    <tr><td class="paramname">hdr</td><td>If true, then this will attempt to use a writer that supports an HDR format before attempting to use an LDR format writer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afde10e16c748638b70b81a7cc0b3456c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afde10e16c748638b70b81a7cc0b3456c">&#9670;&nbsp;</a></span>scaleAlphaToCoverage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::scaleAlphaToCoverage </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>coverage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>alphaRef</em> = <code>0.5f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>alpha_channel</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to scale the alpha channel so that a fraction <code>coverage</code> (between 0 and 1) of the surface has an alpha greater than <code>alphaRef</code>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structnvtt_1_1_surface.html#a3b4cdb2773ea35b42ea460a2b4026cbe" title="Returns the approximate fraction (0 to 1) of the image with an alpha value greater than alphaRef.">alphaTestCoverage()</a> for the method used to determine what fraction passes the alpha test. </dd>
<dd>
Ignacio Casta&ntilde;o, "Computing Alpha Mipmaps" (2010) </dd></dl>

</div>
</div>
<a id="a03f9bb8a615b9b4b583c89ae47b1f08a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f9bb8a615b9b4b583c89ae47b1f08a">&#9670;&nbsp;</a></span>setAtlasBorder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::setAtlasBorder </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draws borders of a given color around each w x h tile contained within the surface, starting from the (0, 0) corner. </p>
<p>In case the surface size is not divisible by the tile size, borders are not drawn for tiles crossing the surface boundary. </p>

</div>
</div>
<a id="ab1f88d67c313490b2ed042c240b718c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1f88d67c313490b2ed042c240b718c2">&#9670;&nbsp;</a></span>setImage() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool nvtt::Surface::setImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenvtt.html#a7ea4cd82d5104d66e14f5524442c5f5e">InputFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>unsignedToSigned</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets this surface given uncompressed input data. </p>
<p>The type of values in <code>data</code> should match <code>format</code>.</p>
<p>If <code>unsignedToSigned</code> is true, <a class="el" href="namespacenvtt.html#a7ea4cd82d5104d66e14f5524442c5f5eaf8b3af0719535e2e45599d0b20a463d2" title="[0, 255] 8 bit uint">InputFormat_BGRA_8UB</a> unsigned input will be converted to signed values between -1 and 1, mapping 0 to -1, and 1...255 linearly to -1...1.</p>
<p>Returns whether setting the image succeeded.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structnvtt_1_1_surface.html#a5a47935fcb94952c439aa5a4e4d4f498" title="Sets this surface to a new w x h x d uninitialized image.">setImage(int, int, int, TimingContext*)</a> </dd></dl>

</div>
</div>
<a id="a6575c5667cd8654ee9d224075f5e3576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6575c5667cd8654ee9d224075f5e3576">&#9670;&nbsp;</a></span>setImage() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool nvtt::Surface::setImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenvtt.html#a7ea4cd82d5104d66e14f5524442c5f5e">InputFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets this surface given uncompressed input data, with different pointers for each channel. </p>
<p>The type of values in <code>data</code> should match <code>format</code>.</p>
<p>Returns whether setting the image succeeded.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structnvtt_1_1_surface.html#a5a47935fcb94952c439aa5a4e4d4f498" title="Sets this surface to a new w x h x d uninitialized image.">setImage(int, int, int, TimingContext*)</a> </dd></dl>

</div>
</div>
<a id="a5a47935fcb94952c439aa5a4e4d4f498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a47935fcb94952c439aa5a4e4d4f498">&#9670;&nbsp;</a></span>setImage() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool nvtt::Surface::setImage </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets this surface to a new w x h x d uninitialized image. </p>
<p>Surfaces are not GPU-enabled by default. The surface's texture type will be set to TextureType_2D if <code>d == 1</code>, and TextureType_3D otherwise. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> </dd></dl>

</div>
</div>
<a id="a2aed8c61f05336b7eab8b2e1431ccc65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aed8c61f05336b7eab8b2e1431ccc65">&#9670;&nbsp;</a></span>setImage3D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool nvtt::Surface::setImage3D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6d">Format</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set surface values from an encoded data source. </p>
<p>For instance, this can be used to decompress BC1-BC7 or ASTC data.</p>
<p>Returns whether setting the image succeeded. </p>

</div>
</div>
<a id="a70bff140663fe8f026a5bc73098a7ce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70bff140663fe8f026a5bc73098a7ce3">&#9670;&nbsp;</a></span>swizzle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::swizzle </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swizzles the channels of the surface. </p>
<p>Each argument specifies where the corresponding channel should come from. For instance, setting r to 2 would mean that the red (0) channel would be set to the current 2nd channel.</p>
<p>In addition, the special values 4, 5, and 6 represent setting the channel to a constant value of 1.0f, 0.0f, or -1.0f, respectively. </p>

</div>
</div>
<a id="afedf5e3d9f8b2b7c9f9709690b26013c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afedf5e3d9f8b2b7c9f9709690b26013c">&#9670;&nbsp;</a></span>toCleanNormalMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::toCleanNormalMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the z (blue) channel to x^2 + y^2. </p>
<p>If the x and y channels represent slopes, instead of normals, then this represents a CLEAN map. The important thing about this is that it can be mipmapped, and the difference between the sum of the square of the first and second mipmapped channels and the third mipmapped channel can be used to determine how rough the normal map is in a given area.</p>
<p>This is a lower-memory and lower-bandwidth version of LEAN mapping, but it has the drawback that it can only represent isotropic roughness.</p>
<dl class="section see"><dt>See also</dt><dd>Olano and Baker, "LEAN Mapping", <a href="https://www.csee.umbc.edu/~olano/papers/lean/">https://www.csee.umbc.edu/~olano/papers/lean/</a> </dd>
<dd>
Hill, "Specular Showdown in the Wild West", <a href="http://blog.selfshadow.com/2011/07/22/specular-showdown/">http://blog.selfshadow.com/2011/07/22/specular-showdown/</a> </dd>
<dd>
<a href="http://gaim.umbc.edu/2011/07/24/shiny-and-clean/">http://gaim.umbc.edu/2011/07/24/shiny-and-clean/</a> </dd>
<dd>
<a href="http://gaim.umbc.edu/2011/07/26/on-error/">http://gaim.umbc.edu/2011/07/26/on-error/</a> </dd></dl>

</div>
</div>
<a id="a58d2adde550afe049b5fb0f726ad41c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58d2adde550afe049b5fb0f726ad41c5">&#9670;&nbsp;</a></span>ToCPU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::ToCPU </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes succeeding operations work on the CPU buffer. </p>
<p>This copies the surface's GPU buffer to the CPU buffer, then destroys the GPU buffer.</p>
<dl class="section since"><dt>Since</dt><dd>NVTT 3.0 </dd></dl>

</div>
</div>
<a id="a6b256ef10f8640189647d04ab7131188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b256ef10f8640189647d04ab7131188">&#9670;&nbsp;</a></span>toGamma() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::toGamma </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>gamma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raises channels 0...2 to the power <code>1/gamma</code>. </p>
<p><code>gamma=2.2</code> approximates linear-to-sRGB conversion.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structnvtt_1_1_surface.html#a5fb44e96cba47c376b117c55380c59df" title="Raises channels 0...2 to the power gamma.">toLinear()</a> </dd>
<dd>
<a class="el" href="structnvtt_1_1_surface.html#a17627047b1633a02c1d78e8de403bb6a" title="Applies the linear-to-sRGB transfer function to channels 0...2.">toSrgb()</a> </dd></dl>

</div>
</div>
<a id="af796ccf711307fbbec4a2150612536f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af796ccf711307fbbec4a2150612536f8">&#9670;&nbsp;</a></span>toGamma() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::toGamma </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>gamma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raises the given channel to the power <code>1/gamma</code>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structnvtt_1_1_surface.html#a6b256ef10f8640189647d04ab7131188" title="Raises channels 0...2 to the power 1/gamma.">toGamma(float, TimingContext*)</a> </dd></dl>

</div>
</div>
<a id="aba4b4cc0b224540af8172c96080d1104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba4b4cc0b224540af8172c96080d1104">&#9670;&nbsp;</a></span>ToGPU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::ToGPU </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>performCopy</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes succeeding operations work on the GPU buffer. </p>
<p>This also copies the surface's CPU data to a new or recreated GPU buffer.</p>
<dl class="section since"><dt>Since</dt><dd>NVTT 3.0 </dd></dl>

</div>
</div>
<a id="adf34d2e2d64895e2f8983b6bb12f7fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf34d2e2d64895e2f8983b6bb12f7fb6">&#9670;&nbsp;</a></span>toGreyScale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::toGreyScale </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>redScale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>greenScale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>blueScale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>alphaScale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets channels 0...3 to the result of converting to grayscale, with customizable channel weights. </p>
<p>For instance, this can be used to give green a higher weight than red or blue when computing luminance. This function will normalize the different scales so they sum to 1, so e.g. (2, 4, 1, 0) are valid scales. The greyscale value is then computed using </p><div class="fragment"><div class="line">grey = r * redScale + g * greenScale + b * blueScale + a * alphaScale</div>
</div><!-- fragment --><p> and then all channels (including alpha) are set to <code>grey</code>. </p>

</div>
</div>
<a id="a5fb44e96cba47c376b117c55380c59df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb44e96cba47c376b117c55380c59df">&#9670;&nbsp;</a></span>toLinear() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::toLinear </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>gamma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raises channels 0...2 to the power <code>gamma</code>. </p>
<p><code>gamma=2.2</code> approximates sRGB-to-linear conversion.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structnvtt_1_1_surface.html#a6b256ef10f8640189647d04ab7131188" title="Raises channels 0...2 to the power 1/gamma.">toGamma()</a> </dd>
<dd>
<a class="el" href="structnvtt_1_1_surface.html#a80080f94846613535e5e7abbb61a8a7e" title="Applies the sRGB-to-linear transfer function to channels 0...2.">toLinearFromSrgb()</a> </dd></dl>

</div>
</div>
<a id="a88333478a4689b0548036cae534a7b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88333478a4689b0548036cae534a7b8c">&#9670;&nbsp;</a></span>toLinear() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::toLinear </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>gamma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raises the given channel to the power <code>gamma</code>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structnvtt_1_1_surface.html#a5fb44e96cba47c376b117c55380c59df" title="Raises channels 0...2 to the power gamma.">toLinear(float, TimingContext*)</a> </dd></dl>

</div>
</div>
<a id="a80080f94846613535e5e7abbb61a8a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80080f94846613535e5e7abbb61a8a7e">&#9670;&nbsp;</a></span>toLinearFromSrgb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::toLinearFromSrgb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the sRGB-to-linear transfer function to channels 0...2. </p>
<p>This transfer function replaces each value <code>x</code> with </p><div class="fragment"><div class="line">if x &lt; 0.0f, 0.0f</div>
<div class="line">if x &lt; 0.04045f, x / 12.92f</div>
<div class="line">if x &lt; 1.0f, powf((x + 0.055f)/1.055f, 2.4f)</div>
<div class="line">otherwise, 1.0f</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="structnvtt_1_1_surface.html#a17627047b1633a02c1d78e8de403bb6a" title="Applies the linear-to-sRGB transfer function to channels 0...2.">toSrgb()</a> </dd></dl>

</div>
</div>
<a id="a7b859aa7259a5283eaabc3e7680d2cd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b859aa7259a5283eaabc3e7680d2cd9">&#9670;&nbsp;</a></span>toLinearFromSrgbUnclamped()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::toLinearFromSrgbUnclamped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the sRGB-to-linear transfer function to channels 0...2, but does not clamp output to [0,1]. </p>
<p>The motivation for this function is that it can approximately preserve HDR values through sRGB conversion and back; that is, s.toSrgbUnclamped().<a class="el" href="structnvtt_1_1_surface.html#a7b859aa7259a5283eaabc3e7680d2cd9" title="Applies the sRGB-to-linear transfer function to channels 0...2, but does not clamp output to [0,...">toLinearFromSrgbUnclamped()</a> is close to s.</p>
<p>This transfer function replaces each value <code>x</code> with </p><div class="fragment"><div class="line">if x is NaN or x &lt;= 0.0f, x</div>
<div class="line">if x &lt; 0.04045f, x / 12.92f</div>
<div class="line">otherwise, powf((x + 0.055f)/1.055f, 2.4f)</div>
</div><!-- fragment --><dl class="section since"><dt>Since</dt><dd>NVTT 3.2 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structnvtt_1_1_surface.html#afcce47cfb9450d88f90415a937746a00" title="Applies the linear-to-sRGB transfer function to channels 0...2, but does not clamp output to [0,...">toSrgbUnclamped()</a> </dd></dl>

</div>
</div>
<a id="a2c8c197a640f3e5ee8c21eb5b2616143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c8c197a640f3e5ee8c21eb5b2616143">&#9670;&nbsp;</a></span>toLinearFromXenonSrgb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::toLinearFromXenonSrgb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts colors in channels 0...2 from the Xenon sRGB piecewise linear sRGB approximation to linear. </p>
<p>This transfer function replaces each value <code>x</code> with </p><div class="fragment"><div class="line">if x &lt; 0,    0.0f</div>
<div class="line">if x &lt; 1/4,  x/4.0f</div>
<div class="line">if x &lt; 3/8, (x - 0.125f) / 2.0f</div>
<div class="line">if x &lt; 3/4,  x - 0.25f</div>
<div class="line">if x &lt; 1,   (x - 0.5f) / 0.5f</div>
<div class="line">otherwise, 1.0f</div>
</div><!-- fragment --><dl class="section since"><dt>Since</dt><dd>NVTT 3.2 </dd></dl>
<dl class="section see"><dt>See also</dt><dd>Alex Vlachos, Post Processing in The Orange Box, GDC 2008 </dd>
<dd>
<a class="el" href="structnvtt_1_1_surface.html#a7b196745118c02562e7e9cfe017e3f33" title="Converts colors in channels 0...2 from linear to a piecewise linear sRGB approximation.">toXenonSrgb()</a> </dd></dl>

</div>
</div>
<a id="a1e3c65e88161fa460176805370b47653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e3c65e88161fa460176805370b47653">&#9670;&nbsp;</a></span>toLM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::toLM </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>range</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>0.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores luminance-only values in a two-channel way. Maybe consider BC4 compression instead. </p>
<p>Luminance <code>L</code> is computed by averaging the red, green, and blue values, while <code>M</code> stores the max of these values and <code>threshold</code>. The red, green, and blue channels then store <code>L/M</code>, and the alpha channel stores <code>(M - threshold)/(1 - threshold)</code>. <br  />
 </p>

</div>
</div>
<a id="ab042fa04f955079c069a5161ed2c3135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab042fa04f955079c069a5161ed2c3135">&#9670;&nbsp;</a></span>toLUVW()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::toLUVW </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>range</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts from RGB colors to a (U, V, W, L) color space, much like RGBM. </p>
<p>All values are clamped to [0, 1]. Then a luminance-like value <code>L</code> is computed from RGB using</p>
<p><code>L = max(sqrtf(R^2 + G^2 + B^2), 1e-6f)</code>.</p>
<p>This then stores the value <code>(R/L, G/L, B/L, L/sqrt(3))</code>. </p>

</div>
</div>
<a id="a43fc10ca72b55a14abaec47e0264314e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43fc10ca72b55a14abaec47e0264314e">&#9670;&nbsp;</a></span>toneMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::toneMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenvtt.html#a30709ef62a9d666f2be7f34cce8e3b94">ToneMapper</a>&#160;</td>
          <td class="paramname"><em>tm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies an HDR-to-LDR tone mapper. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacenvtt.html#a30709ef62a9d666f2be7f34cce8e3b94" title="Tone mapping functions.">ToneMapper</a> for definitions of the tone mappers. </dd></dl>

</div>
</div>
<a id="ab9b7f9167b3996bf7228daf6c894993b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9b7f9167b3996bf7228daf6c894993b">&#9670;&nbsp;</a></span>toNormalMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::toNormalMap </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>medium</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>big</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>large</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the RGB channels to a normal map generated by interpreting the alpha channel as a heightmap, using a blend of four small-scale to large-scale Sobel kernels. </p>
<p>This uses a 9x9 kernel which is a weighted sum of a 3x3 (small), 5x5 (medium), 7x7 (big), and 9x9 (large) differentiation kernels. Each of the weights can be greater than 1, or even negative. However, the kernel will be normalized so that its elements sum to 1, so scaling should be done on the alpha channel beforehand. The smallest kernel focuses on the highest-frequency details, and larger kernels attenuate higher frequencies.</p>
<p>The source alpha channel, which is used as a height map to differentiate, is copied to the output.</p>
<p>The output RGB channels will be in the ranges [-1, 1], [-1, 1], and [0, 1].</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structnvtt_1_1_surface.html#a2db053835be6f1060c414e46d34385db" title="Convolves a channel with a kernel.">convolve()</a> </dd></dl>

</div>
</div>
<a id="ab22a21fb2c5a0b73cadf905a90df96ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab22a21fb2c5a0b73cadf905a90df96ec">&#9670;&nbsp;</a></span>toRGBE()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::toRGBE </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mantissaBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>exponentBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Produces a shared-exponent Red, Green, Blue, Exponent encoding of the HDR RGB channels, such as R9G9B9E5. </p>
<p><code>mantissaBits</code> and <code>exponentBits</code> must be in the range 1...31.</p>
<p>See <a class="el" href="structnvtt_1_1_surface.html#ac739fbfff5eb5237ca7d3635477681cc" title="Produces HDR (r, g, b, 1) values from an LDR (red, green, blue, exponent) storage method.">fromRGBE()</a> for the storage method. This uses an iterative compression approach to reduce the error with regard to decoding. </p>

</div>
</div>
<a id="ae49d2c1546b1c1f4c92798d068906574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae49d2c1546b1c1f4c92798d068906574">&#9670;&nbsp;</a></span>toRGBM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::toRGBM </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>range</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>0.25f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Produces an LDR Red, Green, Blue, Magnitude encoding of the HDR RGB channels. </p>
<p>See <a class="el" href="structnvtt_1_1_surface.html#a37ee98276a237caf39437f5aa64730e0" title="Produces HDR (r, g, b, 1) values from an LDR (red, green, blue, magnitude) storage method.">fromRGBM()</a> for the storage method. This uses an iterative compression approach to reduce the error with regard to decoding. <br  />
 </p>

</div>
</div>
<a id="a17627047b1633a02c1d78e8de403bb6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17627047b1633a02c1d78e8de403bb6a">&#9670;&nbsp;</a></span>toSrgb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::toSrgb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the linear-to-sRGB transfer function to channels 0...2. </p>
<p>This transfer function replaces each value <code>x</code> with </p><div class="fragment"><div class="line">if x is NaN or x &lt;= 0.0f, 0.0f</div>
<div class="line">if x &lt;= 0.0031308f, 12.92f * x</div>
<div class="line">if x &lt;  1.0f, powf(x, 1.0f/2.4f) * 1.055f - 0.055f</div>
<div class="line">otherwise, 1.0f</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="structnvtt_1_1_surface.html#a80080f94846613535e5e7abbb61a8a7e" title="Applies the sRGB-to-linear transfer function to channels 0...2.">toLinearFromSrgb()</a> </dd></dl>

</div>
</div>
<a id="afcce47cfb9450d88f90415a937746a00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcce47cfb9450d88f90415a937746a00">&#9670;&nbsp;</a></span>toSrgbUnclamped()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::toSrgbUnclamped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the linear-to-sRGB transfer function to channels 0...2, but does not clamp output to [0,1]. </p>
<p>The motivation for this function is that it can approximately preserve HDR values through sRGB conversion and back; that is, s.toSrgbUnclamped().<a class="el" href="structnvtt_1_1_surface.html#a7b859aa7259a5283eaabc3e7680d2cd9" title="Applies the sRGB-to-linear transfer function to channels 0...2, but does not clamp output to [0,...">toLinearFromSrgbUnclamped()</a> is close to s.</p>
<p>This transfer function replaces each value <code>x</code> with </p><div class="fragment"><div class="line">if x is NaN or x &lt;= 0.0f, x</div>
<div class="line">if x &lt;= 0.0031308f, 12.92f * x</div>
<div class="line">otherwise, powf(x, 1.0f/2.4f) * 1.055f - 0.055f</div>
</div><!-- fragment --><dl class="section since"><dt>Since</dt><dd>NVTT 3.2 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structnvtt_1_1_surface.html#a7b859aa7259a5283eaabc3e7680d2cd9" title="Applies the sRGB-to-linear transfer function to channels 0...2, but does not clamp output to [0,...">toLinearFromSrgbUnclamped()</a> </dd></dl>

</div>
</div>
<a id="a7b196745118c02562e7e9cfe017e3f33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b196745118c02562e7e9cfe017e3f33">&#9670;&nbsp;</a></span>toXenonSrgb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::toXenonSrgb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts colors in channels 0...2 from linear to a piecewise linear sRGB approximation. </p>
<p>This transfer function replaces each value <code>x</code> with </p><div class="fragment"><div class="line">if x &lt; 0,    0.0f</div>
<div class="line">if x &lt; 1/16, 4.0f * x</div>
<div class="line">if x &lt; 1/8,  2.0f * x + 0.125f</div>
<div class="line">if x &lt; 1/2,         x + 0.25f</div>
<div class="line">if x &lt; 1,    0.5f * x + 0.5f</div>
<div class="line">otherwise, 1.0f</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>Alex Vlachos, Post Processing in The Orange Box, GDC 2008 </dd>
<dd>
<a class="el" href="structnvtt_1_1_surface.html#a2c8c197a640f3e5ee8c21eb5b2616143" title="Converts colors in channels 0...2 from the Xenon sRGB piecewise linear sRGB approximation to linear.">toLinearFromXenonSrgb()</a> </dd></dl>

</div>
</div>
<a id="a11b5be8a1824b6927fdbb42c5e19d7d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11b5be8a1824b6927fdbb42c5e19d7d9">&#9670;&nbsp;</a></span>toYCoCg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::toYCoCg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts from <code>(r, g, b, -)</code> colors to <code>(Co, Cg, 1, Y)</code> colors. </p>
<p>This is useful for formats that use chroma subsampling.</p>
<p>Y is in the range [0, 1], while Co and Cg are in the range [-1, 1].</p>
<p>The RGB-to-YCoCg formula used is </p><div class="fragment"><div class="line">Y  = (2g + r + b)/4</div>
<div class="line">Co = r - b</div>
<div class="line">Cg = (2g - r - b)/2</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8b1b394127ba32bbe97cf0ca6565dfab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b1b394127ba32bbe97cf0ca6565dfab">&#9670;&nbsp;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::transform </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>w0</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>w1</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>w2</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>w3</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>offset</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a 4x4 affine transformation to the values in channels 0...3. </p>
<p><code>w0</code>...<code>w3</code> are the columns of the matrix. <code>offset</code> is added after the matrix-vector multiplication.</p>
<p>In other words, all (r, g, b, a) values are replaced with </p><div class="fragment"><div class="line">(r)   (w0[0], w1[0], w2[0], w3[0]) (r)   (offset[0])</div>
<div class="line">(g) = (w0[1], w1[1], w2[1], w3[1]) (g) + (offset[1])</div>
<div class="line">(b)   (w0[2], w1[2], w2[2], w3[2]) (b)   (offset[2])</div>
<div class="line">(a)   (w0[3], w1[3], w2[3], w3[3]) (a)   (offset[3])</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa9589b42199086cf7fcb4f99a0bd243d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9589b42199086cf7fcb4f99a0bd243d">&#9670;&nbsp;</a></span>transformNormals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::Surface::transformNormals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenvtt.html#a445e3b46e43013ef66771e98f7b1e0ba">NormalTransform</a>&#160;</td>
          <td class="paramname"><em>xform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a 3D-&gt;2D normal transformation, setting the z (blue) channel to 0. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacenvtt.html#a445e3b46e43013ef66771e98f7b1e0ba" title="Specifies a normal transformation, used to store 3D (x, y, z) normals in 2D (x, y).">NormalTransform</a> for definitions of each of the normal transformations. </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>nvtt/<a class="el" href="nvtt_8h_source.html">nvtt.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
