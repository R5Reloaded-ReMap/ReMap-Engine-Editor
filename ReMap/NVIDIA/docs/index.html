<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nvtt: NVTT 3 - API Introduction</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">nvtt
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">NVTT 3 - API Introduction </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="mainpage"></a></p>
<p>NVTT 3 is a library that can be used to compress image data and files into compressed texture formats, and to handle compressed and uncompressed images.</p>
<p>In NVTT 3, most compression algorithms and image processing algorithms can be accelerated by the GPU. These have CPU fallbacks for GPUs without support for CUDA.</p>
<p>The NVTT 3 C++ APIs consist of 2 headers. The high-level APIs are defined in <a class="el" href="nvtt_8h.html">nvtt/nvtt.h</a>. These APIs include image I/O, image processing, and general interfaces for image compression - the main functionality.</p>
<p>The low-level APIs are exposed through <a class="el" href="nvtt__lowlevel_8h.html">nvtt/nvtt_lowlevel.h</a>. This includes individual functions for compressing to each of the supported texture formats. In addition, these allow inputs and outputs to each be located on the CPU or GPU, and give more freedom with regard to image layouts. The high-level APIs are based on the low-level APIs.</p>
<p>In addition, a C wrapper for other compilers and programming languages is available through nvtt/nvtt_wrapper.h.</p>
<p>Here we give some examples with reference code of using the high-level and low-level APIs. More samples covering a range of features will be available at <a href="https://github.com/nvpro-samples/nvtt_samples">https://github.com/nvpro-samples/nvtt_samples</a>.</p>
<h1><a class="anchor" id="autotoc_md0"></a>
Using the high-level APIs</h1>
<h2><a class="anchor" id="autotoc_md1"></a>
Compressing a single file</h2>
<p>First, create an <a class="el" href="structnvtt_1_1_context.html" title="Compression context.">nvtt::Context</a>. Contexts are used both for global settings and for controlling the compression process:</p>
<div class="fragment"><div class="line"><a class="code" href="structnvtt_1_1_context.html">nvtt::Context</a> context;</div>
<div class="line">context.<a class="code" href="structnvtt_1_1_context.html#a8191fdc9c711b060013edccd0162f02f">enableCudaAcceleration</a>(<span class="keyword">true</span>);</div>
<div class="line"><span class="comment">// Now all context compression will be CUDA-accelerated if any system GPU supports it.</span></div>
<div class="ttc" id="astructnvtt_1_1_context_html"><div class="ttname"><a href="structnvtt_1_1_context.html">nvtt::Context</a></div><div class="ttdoc">Compression context.</div><div class="ttdef"><b>Definition:</b> nvtt.h:455</div></div>
<div class="ttc" id="astructnvtt_1_1_context_html_a8191fdc9c711b060013edccd0162f02f"><div class="ttname"><a href="structnvtt_1_1_context.html#a8191fdc9c711b060013edccd0162f02f">nvtt::Context::enableCudaAcceleration</a></div><div class="ttdeci">NVTT_API void enableCudaAcceleration(bool enable)</div><div class="ttdoc">Enable CUDA acceleration; initializes CUDA if not already initialized.</div></div>
</div><!-- fragment --><p>In NVTT, we use <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">nvtt::Surface</a> to store a single uncompressed image. <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">nvtt::Surface</a> has a method <a class="el" href="structnvtt_1_1_surface.html#a7162b072976c0134a3854df107c2b7d5" title="Loads texture data from a file.">nvtt::Surface::load()</a>, which can be used to load an image file. A typical image loading process looks like this:</p>
<div class="fragment"><div class="line"><a class="code" href="structnvtt_1_1_surface.html">nvtt::Surface</a> image;</div>
<div class="line">image.<a class="code" href="structnvtt_1_1_surface.html#a7162b072976c0134a3854df107c2b7d5">load</a>(inputFileName);</div>
<div class="ttc" id="astructnvtt_1_1_surface_html"><div class="ttname"><a href="structnvtt_1_1_surface.html">nvtt::Surface</a></div><div class="ttdoc">A surface is one level of a 2D or 3D texture.</div><div class="ttdef"><b>Definition:</b> nvtt.h:674</div></div>
<div class="ttc" id="astructnvtt_1_1_surface_html_a7162b072976c0134a3854df107c2b7d5"><div class="ttname"><a href="structnvtt_1_1_surface.html#a7162b072976c0134a3854df107c2b7d5">nvtt::Surface::load</a></div><div class="ttdeci">NVTT_API bool load(const char *fileName, bool *hasAlpha=0, bool expectSigned=false, TimingContext *tc=0)</div><div class="ttdoc">Loads texture data from a file.</div></div>
</div><!-- fragment --><p>Then, we set up compression options using <a class="el" href="structnvtt_1_1_compression_options.html" title="Compression options. This class describes the desired compression format and other compression settin...">nvtt::CompressionOptions</a>:</p>
<div class="fragment"><div class="line"><a class="code" href="structnvtt_1_1_compression_options.html">nvtt::CompressionOptions</a> compressionOptions;</div>
<div class="line"><span class="comment">// Compress to 4-channel, 8-bit-per-pixel BC3:</span></div>
<div class="line">compressionOptions.<a class="code" href="structnvtt_1_1_compression_options.html#ad5cef3af27cb8944f54d475c3bbcc89c">setFormat</a>(<a class="code" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6dac8ee0455899fe6fde42300df20aaf282">nvtt::Format_BC3</a>);</div>
<div class="ttc" id="anamespacenvtt_html_a77ad50b0ef658f079f5ec637a287fd6dac8ee0455899fe6fde42300df20aaf282"><div class="ttname"><a href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6dac8ee0455899fe6fde42300df20aaf282">nvtt::Format_BC3</a></div><div class="ttdeci">@ Format_BC3</div><div class="ttdoc">DX10 - BC3 (DXT5) format.</div><div class="ttdef"><b>Definition:</b> nvtt_lowlevel.h:225</div></div>
<div class="ttc" id="astructnvtt_1_1_compression_options_html"><div class="ttname"><a href="structnvtt_1_1_compression_options.html">nvtt::CompressionOptions</a></div><div class="ttdoc">Compression options. This class describes the desired compression format and other compression settin...</div><div class="ttdef"><b>Definition:</b> nvtt.h:64</div></div>
<div class="ttc" id="astructnvtt_1_1_compression_options_html_ad5cef3af27cb8944f54d475c3bbcc89c"><div class="ttname"><a href="structnvtt_1_1_compression_options.html#ad5cef3af27cb8944f54d475c3bbcc89c">nvtt::CompressionOptions::setFormat</a></div><div class="ttdeci">NVTT_API void setFormat(Format format)</div><div class="ttdoc">Set desired compression format.</div></div>
</div><!-- fragment --><p>See <a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6d" title="Supported block-compression formats, including compressor variants.">nvtt::Format</a> for all compression formats.</p>
<p>Next, we say how to write the compressed data using <a class="el" href="structnvtt_1_1_output_options.html" title="Output Options.">nvtt::OutputOptions</a>. The simplest case is to assign a filename directly:</p>
<div class="fragment"><div class="line"><a class="code" href="structnvtt_1_1_output_options.html">nvtt::OutputOptions</a> outputOptions;</div>
<div class="line">outputOptions.<a class="code" href="structnvtt_1_1_output_options.html#a3d3cc71dba3ca05dabaa73d3a91bd52d">setFileName</a>(outputFileName);</div>
<div class="ttc" id="astructnvtt_1_1_output_options_html"><div class="ttname"><a href="structnvtt_1_1_output_options.html">nvtt::OutputOptions</a></div><div class="ttdoc">Output Options.</div><div class="ttdef"><b>Definition:</b> nvtt.h:411</div></div>
<div class="ttc" id="astructnvtt_1_1_output_options_html_a3d3cc71dba3ca05dabaa73d3a91bd52d"><div class="ttname"><a href="structnvtt_1_1_output_options.html#a3d3cc71dba3ca05dabaa73d3a91bd52d">nvtt::OutputOptions::setFileName</a></div><div class="ttdeci">NVTT_API void setFileName(const char *fileName)</div></div>
</div><!-- fragment --><p>For more dedicated control of the output stream, you may want to derive a subclass of <a class="el" href="structnvtt_1_1_output_handler.html" title="Inheritable interface for outputting data.">nvtt::OutputHandler</a>, then use <a class="el" href="structnvtt_1_1_output_options.html#ad7ac0c427c87129350bdd0ba65970cf1" title="Set output handler.">nvtt::OutputOptions::setOutputHandler</a> to redirect the output:</p>
<div class="fragment"><div class="line">MyOutputHandler outputHandler;</div>
<div class="line">outputOptions.<a class="code" href="structnvtt_1_1_output_options.html#ad7ac0c427c87129350bdd0ba65970cf1">setOutputHandler</a>(&amp;outputHandler);</div>
<div class="ttc" id="astructnvtt_1_1_output_options_html_ad7ac0c427c87129350bdd0ba65970cf1"><div class="ttname"><a href="structnvtt_1_1_output_options.html#ad7ac0c427c87129350bdd0ba65970cf1">nvtt::OutputOptions::setOutputHandler</a></div><div class="ttdeci">NVTT_API void setOutputHandler(OutputHandler *outputHandler)</div><div class="ttdoc">Set output handler.</div></div>
</div><!-- fragment --><p>When the above setup is complete, we compress the image using <a class="el" href="structnvtt_1_1_context.html" title="Compression context.">nvtt::Context</a>.</p>
<div class="fragment"><div class="line">context.<a class="code" href="structnvtt_1_1_context.html#a6048a986e02f7bef941c8a13bbb0df17">outputHeader</a>(image, 1, compressionOptions, outputOptions); <span class="comment">// output DDS header</span></div>
<div class="line">context.<a class="code" href="structnvtt_1_1_context.html#ad3f06959621dd537f1f207b39b086225">compress</a>(image, 0, 0, compressionOptions, outputOptions); <span class="comment">// output compressed image</span></div>
<div class="ttc" id="astructnvtt_1_1_context_html_a6048a986e02f7bef941c8a13bbb0df17"><div class="ttname"><a href="structnvtt_1_1_context.html#a6048a986e02f7bef941c8a13bbb0df17">nvtt::Context::outputHeader</a></div><div class="ttdeci">NVTT_API bool outputHeader(const Surface &amp;img, int mipmapCount, const CompressionOptions &amp;compressionOptions, const OutputOptions &amp;outputOptions) const</div><div class="ttdoc">Write the Container's header to the output.</div></div>
<div class="ttc" id="astructnvtt_1_1_context_html_ad3f06959621dd537f1f207b39b086225"><div class="ttname"><a href="structnvtt_1_1_context.html#ad3f06959621dd537f1f207b39b086225">nvtt::Context::compress</a></div><div class="ttdeci">NVTT_API bool compress(const Surface &amp;img, int face, int mipmap, const CompressionOptions &amp;compressionOptions, const OutputOptions &amp;outputOptions) const</div><div class="ttdoc">Compress the Surface and write the compressed data to the output.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md2"></a>
Loading SurfaceSets from DDS files</h2>
<p>DDS files can contain multiple cube map faces and mipmap levels. To load these surfaces, you may want to use <a class="el" href="structnvtt_1_1_surface_set.html" title="Surface-set struct for convenience of handling multi-level texture files such as DDS,...">nvtt::SurfaceSet</a> as the loader:</p>
<div class="fragment"><div class="line"><a class="code" href="structnvtt_1_1_surface_set.html">nvtt::SurfaceSet</a> images;</div>
<div class="line">images.<a class="code" href="structnvtt_1_1_surface_set.html#a62cbe48d4ec1498d5e5edebb800cb2d8">loadDDS</a>(ddsFileName);</div>
<div class="ttc" id="astructnvtt_1_1_surface_set_html"><div class="ttname"><a href="structnvtt_1_1_surface_set.html">nvtt::SurfaceSet</a></div><div class="ttdoc">Surface-set struct for convenience of handling multi-level texture files such as DDS,...</div><div class="ttdef"><b>Definition:</b> nvtt.h:1384</div></div>
<div class="ttc" id="astructnvtt_1_1_surface_set_html_a62cbe48d4ec1498d5e5edebb800cb2d8"><div class="ttname"><a href="structnvtt_1_1_surface_set.html#a62cbe48d4ec1498d5e5edebb800cb2d8">nvtt::SurfaceSet::loadDDS</a></div><div class="ttdeci">NVTT_API bool loadDDS(const char *fileName, bool forcenormal=false)</div><div class="ttdoc">Load a surface set from a DDS file.</div></div>
</div><!-- fragment --><p>Then you can use <a class="el" href="structnvtt_1_1_surface_set.html#a2810b0e8b80c4401bbcccf556c314ede" title="Get a surface at specified face and mip level.">nvtt::SurfaceSet::GetSurface()</a> to extract each individual <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">nvtt::Surface</a>:</p>
<div class="fragment"><div class="line"><a class="code" href="structnvtt_1_1_surface.html">nvtt::Surface</a> image = images.<a class="code" href="structnvtt_1_1_surface_set.html#a2810b0e8b80c4401bbcccf556c314ede">GetSurface</a>(face, mip);</div>
<div class="ttc" id="astructnvtt_1_1_surface_set_html_a2810b0e8b80c4401bbcccf556c314ede"><div class="ttname"><a href="structnvtt_1_1_surface_set.html#a2810b0e8b80c4401bbcccf556c314ede">nvtt::SurfaceSet::GetSurface</a></div><div class="ttdeci">NVTT_API Surface GetSurface(int faceId, int mipId, bool expectSigned=false)</div><div class="ttdoc">Get a surface at specified face and mip level.</div></div>
</div><!-- fragment --><p>or:</p>
<div class="fragment"><div class="line"><a class="code" href="structnvtt_1_1_surface.html">nvtt::Surface</a> image;</div>
<div class="line">images.<a class="code" href="structnvtt_1_1_surface_set.html#a2810b0e8b80c4401bbcccf556c314ede">GetSurface</a>(face, mip, image);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3"></a>
Compressing multiple files faster</h2>
<p>For batch processing of multiple files, we use <a class="el" href="structnvtt_1_1_batch_list.html" title="Structure defining a list of inputs to be compressed.">nvtt::BatchList</a>.</p>
<div class="fragment"><div class="line"><a class="code" href="structnvtt_1_1_batch_list.html">nvtt::BatchList</a> batchList;</div>
<div class="ttc" id="astructnvtt_1_1_batch_list_html"><div class="ttname"><a href="structnvtt_1_1_batch_list.html">nvtt::BatchList</a></div><div class="ttdoc">Structure defining a list of inputs to be compressed.</div><div class="ttdef"><b>Definition:</b> nvtt.h:1639</div></div>
</div><!-- fragment --><p>Instead of compressing each image one-by-one, now we first append all images to the <code>batchList</code> container. Each image has its own output handler (e.g. to write to multiple files):</p>
<div class="fragment"><div class="line">batchList.<a class="code" href="structnvtt_1_1_batch_list.html#abdaeb97d4bb24d975f9a5354c120995b">Append</a>(image, 0 <span class="comment">/*face*/</span>, 0<span class="comment">/*mip*/</span>, outputOptions1);</div>
<div class="line">batchList.<a class="code" href="structnvtt_1_1_batch_list.html#abdaeb97d4bb24d975f9a5354c120995b">Append</a>(image2, 0 <span class="comment">/*face*/</span>, 0<span class="comment">/*mip*/</span>, outputOptions2);</div>
<div class="line">...</div>
<div class="ttc" id="astructnvtt_1_1_batch_list_html_abdaeb97d4bb24d975f9a5354c120995b"><div class="ttname"><a href="structnvtt_1_1_batch_list.html#abdaeb97d4bb24d975f9a5354c120995b">nvtt::BatchList::Append</a></div><div class="ttdeci">NVTT_API void Append(const Surface *pImg, int face, int mipmap, const OutputOptions *outputOptions)</div><div class="ttdoc">Adds a pointer to the surface, its face and mipmap index, and a pointer to the output method to the i...</div></div>
</div><!-- fragment --><p>Then we issue a single <code><a class="el" href="structnvtt_1_1_context.html#ad3f06959621dd537f1f207b39b086225" title="Compress the Surface and write the compressed data to the output.">nvtt::Context::compress</a></code> command to compress all the inputs:</p>
<div class="fragment"><div class="line">context.<a class="code" href="structnvtt_1_1_context.html#ad3f06959621dd537f1f207b39b086225">compress</a>(batchList, compressionOptions);</div>
</div><!-- fragment --><p>When we do it this way, NVTT 3 will restructure the input images and exploit parallelism to the maximum extent when GPU compression is used, without needing to synchronize with the CPU between images. When there are a large number of small textures to compress with the same <a class="el" href="structnvtt_1_1_compression_options.html" title="Compression options. This class describes the desired compression format and other compression settin...">nvtt::CompressionOptions</a>, batch processing can dramatically increase the performance.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
Decompression</h2>
<p>The decompression routine is relatively straightforward. The function <a class="el" href="structnvtt_1_1_surface_set.html#a62cbe48d4ec1498d5e5edebb800cb2d8" title="Load a surface set from a DDS file.">nvtt::SurfaceSet::loadDDS()</a> can be used to decode a DDS file. After the file is loaded, you can use <a class="el" href="structnvtt_1_1_surface_set.html#a9563de6e1048ae402af174d3461f70d2" title="Save an image at specified face and mip level (for decompression)">nvtt::SurfaceSet::saveImage()</a> to output the result:</p>
<div class="fragment"><div class="line"><a class="code" href="structnvtt_1_1_surface_set.html">nvtt::SurfaceSet</a> images;</div>
<div class="line">images.<a class="code" href="structnvtt_1_1_surface_set.html#a62cbe48d4ec1498d5e5edebb800cb2d8">loadDDS</a>(ddsFileName);         </div>
<div class="line">images.<a class="code" href="structnvtt_1_1_surface_set.html#a9563de6e1048ae402af174d3461f70d2">saveImage</a>(outFileName,face,mip);</div>
<div class="ttc" id="astructnvtt_1_1_surface_set_html_a9563de6e1048ae402af174d3461f70d2"><div class="ttname"><a href="structnvtt_1_1_surface_set.html#a9563de6e1048ae402af174d3461f70d2">nvtt::SurfaceSet::saveImage</a></div><div class="ttdeci">NVTT_API bool saveImage(const char *fileName, int faceId, int mipId)</div><div class="ttdoc">Save an image at specified face and mip level (for decompression)</div></div>
</div><!-- fragment --><p>If you only have compressed data, but know the size and format, you can use <a class="el" href="structnvtt_1_1_surface.html#a4a687a3504eeba283366e36315904aeb" title="Set 2D surface values from an encoded data source. Same as setImage3D() with d=1.">nvtt::Surface::setImage2D()</a> or <a class="el" href="structnvtt_1_1_surface.html#a2aed8c61f05336b7eab8b2e1431ccc65" title="Set surface values from an encoded data source.">nvtt::Surface::setImage3D()</a>:</p>
<div class="fragment"><div class="line"><a class="code" href="structnvtt_1_1_surface.html">nvtt::Surface</a> image;</div>
<div class="line">image.<a class="code" href="structnvtt_1_1_surface.html#a4a687a3504eeba283366e36315904aeb">setImage2D</a>(<a class="code" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6da7504a001d01a2e3f1cda648f1e32676b">nvtt::Format_BC7</a>, width, height, data);</div>
<div class="ttc" id="anamespacenvtt_html_a77ad50b0ef658f079f5ec637a287fd6da7504a001d01a2e3f1cda648f1e32676b"><div class="ttname"><a href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6da7504a001d01a2e3f1cda648f1e32676b">nvtt::Format_BC7</a></div><div class="ttdeci">@ Format_BC7</div><div class="ttdoc">DX10 - BC7 format (four channels, UNORM)</div><div class="ttdef"><b>Definition:</b> nvtt_lowlevel.h:239</div></div>
<div class="ttc" id="astructnvtt_1_1_surface_html_a4a687a3504eeba283366e36315904aeb"><div class="ttname"><a href="structnvtt_1_1_surface.html#a4a687a3504eeba283366e36315904aeb">nvtt::Surface::setImage2D</a></div><div class="ttdeci">NVTT_API bool setImage2D(Format format, int w, int h, const void *data, TimingContext *tc=0)</div><div class="ttdoc">Set 2D surface values from an encoded data source. Same as setImage3D() with d=1.</div></div>
</div><!-- fragment --><p>Note that decompression is currently not GPU accelerated.</p>
<h2><a class="anchor" id="autotoc_md5"></a>
Image processing with nvtt::Surface</h2>
<p>Some useful image processing routines are provided in <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">nvtt::Surface</a>. For example, a downsampling process looks like this:</p>
<div class="fragment"><div class="line"><a class="code" href="structnvtt_1_1_surface.html">nvtt::Surface</a> image;</div>
<div class="line">image.<a class="code" href="structnvtt_1_1_surface.html#a7162b072976c0134a3854df107c2b7d5">load</a>(inputFileName);</div>
<div class="line"> </div>
<div class="line">image.<a class="code" href="structnvtt_1_1_surface.html#aba4b4cc0b224540af8172c96080d1104">ToGPU</a>(); <span class="comment">// this enables GPU acceleration for the succeeding operations    </span></div>
<div class="line">image.<a class="code" href="structnvtt_1_1_surface.html#a80080f94846613535e5e7abbb61a8a7e">toLinearFromSrgb</a>(); <span class="comment">// resizing must be done in linear space</span></div>
<div class="line">image.<a class="code" href="structnvtt_1_1_surface.html#aa8b2bd544a72fb7c60e0106c6f870893">resize</a>(newWidth, newHeight, newDepth, <a class="code" href="namespacenvtt.html#a3607100ce561fdaa3859abd0f05878c7ac608b4be1bb223cfd73e5aac2a002019">nvtt::ResizeFilter_Box</a>);</div>
<div class="line">image.<a class="code" href="structnvtt_1_1_surface.html#a17627047b1633a02c1d78e8de403bb6a">toSrgb</a>();</div>
<div class="ttc" id="anamespacenvtt_html_a3607100ce561fdaa3859abd0f05878c7ac608b4be1bb223cfd73e5aac2a002019"><div class="ttname"><a href="namespacenvtt.html#a3607100ce561fdaa3859abd0f05878c7ac608b4be1bb223cfd73e5aac2a002019">nvtt::ResizeFilter_Box</a></div><div class="ttdeci">@ ResizeFilter_Box</div><div class="ttdef"><b>Definition:</b> nvtt.h:202</div></div>
<div class="ttc" id="astructnvtt_1_1_surface_html_a17627047b1633a02c1d78e8de403bb6a"><div class="ttname"><a href="structnvtt_1_1_surface.html#a17627047b1633a02c1d78e8de403bb6a">nvtt::Surface::toSrgb</a></div><div class="ttdeci">NVTT_API void toSrgb(TimingContext *tc=0)</div><div class="ttdoc">Applies the linear-to-sRGB transfer function to channels 0...2.</div></div>
<div class="ttc" id="astructnvtt_1_1_surface_html_a80080f94846613535e5e7abbb61a8a7e"><div class="ttname"><a href="structnvtt_1_1_surface.html#a80080f94846613535e5e7abbb61a8a7e">nvtt::Surface::toLinearFromSrgb</a></div><div class="ttdeci">NVTT_API void toLinearFromSrgb(TimingContext *tc=0)</div><div class="ttdoc">Applies the sRGB-to-linear transfer function to channels 0...2.</div></div>
<div class="ttc" id="astructnvtt_1_1_surface_html_aa8b2bd544a72fb7c60e0106c6f870893"><div class="ttname"><a href="structnvtt_1_1_surface.html#aa8b2bd544a72fb7c60e0106c6f870893">nvtt::Surface::resize</a></div><div class="ttdeci">NVTT_API void resize(int w, int h, int d, ResizeFilter filter, TimingContext *tc=0)</div><div class="ttdoc">Resizes this surface to have size w x h x d using a given filter.</div></div>
<div class="ttc" id="astructnvtt_1_1_surface_html_aba4b4cc0b224540af8172c96080d1104"><div class="ttname"><a href="structnvtt_1_1_surface.html#aba4b4cc0b224540af8172c96080d1104">nvtt::Surface::ToGPU</a></div><div class="ttdeci">NVTT_API void ToGPU(TimingContext *tc=0, bool performCopy=true)</div><div class="ttdoc">Makes succeeding operations work on the GPU buffer.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md6"></a>
Using the low-level APIs</h1>
<p>The low-level APIs are for compression only.</p>
<p>To use the low-level APIs, there is no need to create an <a class="el" href="structnvtt_1_1_context.html" title="Compression context.">nvtt::Context</a> first, and images do not need to come from <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture.">nvtt::Surface</a>.</p>
<p>At the center of the low-level APIs, there are 2 buffer structs for storing the input image data. <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html" title="Structure containing all the input images from host memory. The image data is reordered by tiles.">nvtt::CPUInputBuffer</a> stores the data in host memory, and <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html" title="Structure containing all the input images from device memory. The image data is reordered by tiles.">nvtt::GPUInputBuffer</a> stores the data in device memory.</p>
<p>For each of the supported texture formats, there are 2 functions that compress textures into that format, each handling one buffer type. For functions using <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html" title="Structure containing all the input images from host memory. The image data is reordered by tiles.">nvtt::CPUInputBuffer</a>, there is a <code>useGpu</code> parameter to choose whether to use the GPU routine to compress it. For the function using <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html" title="Structure containing all the input images from device memory. The image data is reordered by tiles.">nvtt::GPUInputBuffer</a>, the compression is always done by the GPU. In both cases, the user can choose whether the output goes to host memory or device memory using the <code>to_device_mem</code> parameter.</p>
<p>A buffer can be created from one or more images in host memory or device memory. The user must reference each of the input images using the <a class="el" href="structnvtt_1_1_ref_image.html" title="Use this structure to reference each of the input images.">nvtt::RefImage</a> structure.</p>
<p>Here's an example.</p>
<p>First, we use an external tool like stb_image to load a image file:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> chn;</div>
<div class="line"><span class="keywordtype">void</span> *p_img = stbi_load(<span class="stringliteral">&quot;my_texture.png&quot;</span>, &amp;img_in.width, &amp;img_in.height, &amp;chn, 4);</div>
</div><!-- fragment --><p>Second, we use <a class="el" href="structnvtt_1_1_ref_image.html" title="Use this structure to reference each of the input images.">nvtt::RefImage</a> to reference this image:</p>
<div class="fragment"><div class="line"><a class="code" href="structnvtt_1_1_ref_image.html">nvtt::RefImage</a> img_in;</div>
<div class="line">img_in.<a class="code" href="structnvtt_1_1_ref_image.html#a28f7946a03f3887f191c097025fcc916">data</a> = p_img;</div>
<div class="line">img_in.<a class="code" href="structnvtt_1_1_ref_image.html#a775ea94efce207fea55be6fa1e0ce975">num_channels</a> = 4; <span class="comment">// stb_image always produces 4 channels</span></div>
<div class="line"><span class="keywordflow">if</span> (chn == 3)</div>
<div class="line">    img_in.<a class="code" href="structnvtt_1_1_ref_image.html#ad88dd307a6a2b111d6db66193c530f5c">channel_swizzle</a>[3] = nvtt::One; <span class="comment">// alpha channel set to 1 for opaque images</span></div>
<div class="ttc" id="astructnvtt_1_1_ref_image_html"><div class="ttname"><a href="structnvtt_1_1_ref_image.html">nvtt::RefImage</a></div><div class="ttdoc">Use this structure to reference each of the input images.</div><div class="ttdef"><b>Definition:</b> nvtt_lowlevel.h:126</div></div>
<div class="ttc" id="astructnvtt_1_1_ref_image_html_a28f7946a03f3887f191c097025fcc916"><div class="ttname"><a href="structnvtt_1_1_ref_image.html#a28f7946a03f3887f191c097025fcc916">nvtt::RefImage::data</a></div><div class="ttdeci">const void * data</div><div class="ttdoc">For CPUInputBuffer, this should point to host memory; for GPUInputBuffer, this should point to device...</div><div class="ttdef"><b>Definition:</b> nvtt_lowlevel.h:127</div></div>
<div class="ttc" id="astructnvtt_1_1_ref_image_html_a775ea94efce207fea55be6fa1e0ce975"><div class="ttname"><a href="structnvtt_1_1_ref_image.html#a775ea94efce207fea55be6fa1e0ce975">nvtt::RefImage::num_channels</a></div><div class="ttdeci">int num_channels</div><div class="ttdoc">Number of channels the image has.</div><div class="ttdef"><b>Definition:</b> nvtt_lowlevel.h:131</div></div>
<div class="ttc" id="astructnvtt_1_1_ref_image_html_ad88dd307a6a2b111d6db66193c530f5c"><div class="ttname"><a href="structnvtt_1_1_ref_image.html#ad88dd307a6a2b111d6db66193c530f5c">nvtt::RefImage::channel_swizzle</a></div><div class="ttdeci">ChannelOrder channel_swizzle[4]</div><div class="ttdoc">Channels order how the image is stored.</div><div class="ttdef"><b>Definition:</b> nvtt_lowlevel.h:132</div></div>
</div><!-- fragment --><p>Third, we create a <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html" title="Structure containing all the input images from host memory. The image data is reordered by tiles.">nvtt::CPUInputBuffer</a> using the single <a class="el" href="structnvtt_1_1_ref_image.html" title="Use this structure to reference each of the input images.">nvtt::RefImage</a>:</p>
<div class="fragment"><div class="line"><a class="code" href="structnvtt_1_1_c_p_u_input_buffer.html">nvtt::CPUInputBuffer</a> input_buf(&amp;img_in, <a class="code" href="namespacenvtt.html#ae939a4f095a98e5176153b81dba28321a2af64236612722b24eb2b58858257b4b">nvtt::UINT8</a>);</div>
<div class="line">free(p_img); <span class="comment">// data is copied and reordered, the original data can be freed</span></div>
<div class="ttc" id="anamespacenvtt_html_ae939a4f095a98e5176153b81dba28321a2af64236612722b24eb2b58858257b4b"><div class="ttname"><a href="namespacenvtt.html#ae939a4f095a98e5176153b81dba28321a2af64236612722b24eb2b58858257b4b">nvtt::UINT8</a></div><div class="ttdeci">@ UINT8</div><div class="ttdoc">8-bit unsigned integer.</div><div class="ttdef"><b>Definition:</b> nvtt_lowlevel.h:107</div></div>
<div class="ttc" id="astructnvtt_1_1_c_p_u_input_buffer_html"><div class="ttname"><a href="structnvtt_1_1_c_p_u_input_buffer.html">nvtt::CPUInputBuffer</a></div><div class="ttdoc">Structure containing all the input images from host memory. The image data is reordered by tiles.</div><div class="ttdef"><b>Definition:</b> nvtt_lowlevel.h:139</div></div>
</div><!-- fragment --><p>We then prepare a buffer for receiving compressed BC1 data:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span>* outbuf = malloc(input_buf.NumTiles() * 8); <span class="comment">// BC1 uses 8 bytes/tile</span></div>
</div><!-- fragment --><p>Finally, call the BC1 compressing function:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> settings = <a class="code" href="structnvtt_1_1_encode_settings.html">nvtt::EncodeSettings</a>().<a class="code" href="structnvtt_1_1_encode_settings.html#a74982ce389fe74fca51a41107c89ca3c">SetFormat</a>(<a class="code" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6da9ca8e3f8d05a0fae928ae309608ef722">nvtt::Format_DXT1</a>)</div>
<div class="line">    .SetQuality(nvtt::Quality_Normal)</div>
<div class="line">    .<a class="code" href="structnvtt_1_1_encode_settings.html#aa99a837bab79fe40f342cd6c40fea3f6">SetUseGPU</a>(<span class="keyword">true</span>)</div>
<div class="line">    .<a class="code" href="structnvtt_1_1_encode_settings.html#ab3b2eeebbc64705cc5086057bef03adc">SetOutputToGPUMem</a>(<span class="keyword">false</span>);</div>
<div class="line"><span class="keywordtype">bool</span> ret = <a class="code" href="namespacenvtt.html#a14ef44c2a4c9551980d0e85635a47e2a">nvtt_encode</a>(input_buf, outbuf, settings);</div>
<div class="ttc" id="anamespacenvtt_html_a14ef44c2a4c9551980d0e85635a47e2a"><div class="ttname"><a href="namespacenvtt.html#a14ef44c2a4c9551980d0e85635a47e2a">nvtt::nvtt_encode</a></div><div class="ttdeci">bool NVTT_API nvtt_encode(const CPUInputBuffer &amp;input, void *output, const EncodeSettings &amp;settings)</div></div>
<div class="ttc" id="anamespacenvtt_html_a77ad50b0ef658f079f5ec637a287fd6da9ca8e3f8d05a0fae928ae309608ef722"><div class="ttname"><a href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6da9ca8e3f8d05a0fae928ae309608ef722">nvtt::Format_DXT1</a></div><div class="ttdeci">@ Format_DXT1</div><div class="ttdoc">DX9 - DXT1 format.</div><div class="ttdef"><b>Definition:</b> nvtt_lowlevel.h:215</div></div>
<div class="ttc" id="astructnvtt_1_1_encode_settings_html"><div class="ttname"><a href="structnvtt_1_1_encode_settings.html">nvtt::EncodeSettings</a></div><div class="ttdef"><b>Definition:</b> nvtt_lowlevel.h:379</div></div>
<div class="ttc" id="astructnvtt_1_1_encode_settings_html_a74982ce389fe74fca51a41107c89ca3c"><div class="ttname"><a href="structnvtt_1_1_encode_settings.html#a74982ce389fe74fca51a41107c89ca3c">nvtt::EncodeSettings::SetFormat</a></div><div class="ttdeci">NVTT_API EncodeSettings &amp; SetFormat(Format _format)</div></div>
<div class="ttc" id="astructnvtt_1_1_encode_settings_html_aa99a837bab79fe40f342cd6c40fea3f6"><div class="ttname"><a href="structnvtt_1_1_encode_settings.html#aa99a837bab79fe40f342cd6c40fea3f6">nvtt::EncodeSettings::SetUseGPU</a></div><div class="ttdeci">NVTT_API EncodeSettings &amp; SetUseGPU(bool _use_gpu)</div></div>
<div class="ttc" id="astructnvtt_1_1_encode_settings_html_ab3b2eeebbc64705cc5086057bef03adc"><div class="ttname"><a href="structnvtt_1_1_encode_settings.html#ab3b2eeebbc64705cc5086057bef03adc">nvtt::EncodeSettings::SetOutputToGPUMem</a></div><div class="ttdeci">NVTT_API EncodeSettings &amp; SetOutputToGPUMem(bool _to_device_mem)</div></div>
</div><!-- fragment --><p>The raw compressed blocks will then be stored in <code>outbuf</code>. The low-level APIs do not generate file headers (such as DDS file headers).</p>
<h1><a class="anchor" id="autotoc_md7"></a>
Building with NVTT 3</h1>
<p>To add the dynamic build of NVTT 3 to a C++ application, link with <code>nvtt.lib</code> in the <code>lib/</code> folder, include <code><a class="el" href="nvtt_8h.html">nvtt/nvtt.h</a></code>, and copy <code>nvtt.dll</code> to the application output directory.</p>
<p>Example CMake applications using this process can be found at the <a href="https://github.com/nvpro-samples/nvtt3_samples.">online samples repository</a>; most of the work in the CMake file there is in locating the system's NVTT distribution.</p>
<p>The C++ API should be compatible with any MSVC 14x toolset. For other toolsets and other programming languages, please use the C wrapper in nvtt/nvtt_wrapper.h.</p>
<p>The dynamic build can also be <a href="https://docs.microsoft.com/en-us/cpp/build/reference/linker-support-for-delay-loaded-dlls">delay-loaded</a>.</p>
<h1><a class="anchor" id="autotoc_md8"></a>
Considerations for CUDA compatibility</h1>
<p>The following notes are important for apps using CUDA elsewhere.</p>
<p>NVTT 3 uses the CUDA Runtime API, and certain functions such as <a class="el" href="structnvtt_1_1_context.html#a8191fdc9c711b060013edccd0162f02f" title="Enable CUDA acceleration; initializes CUDA if not already initialized.">nvtt::Context::enableCudaAcceleration()</a> and <a class="el" href="namespacenvtt.html#a07e1ba1bbab69167fca20f080ca9ce8e" title="Check if CUDA is supported by the run-time environment.">nvtt::isCudaSupported()</a> can choose a device and call <code>cudaSetDevice()</code> unless <a class="el" href="namespacenvtt.html#a4331c366610258762f80c8a3d7ee6910" title="Tells NVTT to always use an application-set device rather than selecting its own.">nvtt::useCurrentDevice()</a> has been called first. When using NVTT 3 with other CUDA functionality, we recommend doing two things:</p>
<ol type="1">
<li>Call <a class="el" href="namespacenvtt.html#a4331c366610258762f80c8a3d7ee6910" title="Tells NVTT to always use an application-set device rather than selecting its own.">nvtt::useCurrentDevice()</a> and <code>cudaSetDevice()</code> before any other NVTT 3 functions. Calling <a class="el" href="namespacenvtt.html#a4331c366610258762f80c8a3d7ee6910" title="Tells NVTT to always use an application-set device rather than selecting its own.">useCurrentDevice()</a> will prevent NVTT from choosing and changing the device. It only needs to be called once during the lifetime of the application.</li>
<li>When passing device pointers to NVTT, make sure the pointer refers to memory NVTT's device (and <a href="https://docs.nvidia.com/cuda/cuda-driver-api/driver-vs-runtime-api.html">runtime API context</a> if using the CUDA Driver API) can access. Similarly, when accessing data from device pointers returned from NVTT, make sure the current device (and context, if using the CUDA Driver API) can access allocations made by NVTT's device using the CUDA Runtime API. Device pointers are returned from <a class="el" href="structnvtt_1_1_surface.html#aefedacd34e62dad9a3908a4bbdbf9ed3" title="Get a CUDA pointer to const image data on the GPU, using the same layout as data()....">nvtt::Surface::gpuData()</a>, and used in the low-level GPU compression function API in <a class="el" href="nvtt__lowlevel_8h.html">nvtt_lowlevel.h</a>. </li>
</ol>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
